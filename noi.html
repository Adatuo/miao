<!-- saved from url=(0051)https://class.damiaoedu.com:44313/codes/js/noi.html -->
<html class="trancy-zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <head>
    <script type="ok" id="ch0103/01">
  var a = Number(prompt('请输入A'))
  var b = Number(prompt('请输入B'))

  var c = a + b

  console.log(c)
</script>

    <script type="ok" id="ch0103/02">
  var a = Number(prompt('请输入A'))
  var b = Number(prompt('请输入B'))
  var c = Number(prompt('请输入C'))

  var result = (a + b) * c

  console.log(result)
</script>

    <script type="ok" id="ch0103/03">

  var a = parseInt(prompt('请输入A'))
  var b = parseInt(prompt('请输入B'))
  var c = parseInt(prompt('请输入C'))

  var result = parseInt((a + b) / c) //取整运算，所以为0

  //x % 1,取得小数部分
  console.log(result)
	
</script>

    <script type="ok" id="ch0103/04">

  var a = parseInt(prompt('请输入除数（除数非零）'))
  var b = parseInt(prompt('请输入被除数'))

  var result1 =parseInt( a / b )
  var result2 = a % b

  console.log(result1)
  console.log(result2)
	
</script>

    <script type="ok" id="ch0103/05">

  var a = parseFloat((prompt('请输入整数')))
  var b = parseFloat((prompt('请输入整数（不为0）')))

  var result = a / b
 

  console.log(result.toFixed(9))

	
</script>

    <script type="ok" id="ch0103/06">

  var a = Number((prompt('请输入确诊数(10433)')))
  var b = Number((prompt('请输入死亡数（60）')))

  var result = b / a
 

  console.log((result * 100).toFixed(3) + '%') //先✖100，然后使用toFixed()函数，保留几位小数

	
</script>

    <script type="ok" id="ch0103/07">

  var x = Number((prompt('请输入x(不超过100)')))
  var a = Number((prompt('请输入a(不超过100)')))
  var b = Number((prompt('请输入b(不超过100)')))
  var c = Number((prompt('请输入c(不超过100)')))
  var d = Number((prompt('请输入d(不超过100)')))
  var result = a * x ** 3 + b * x ** 2 + c * x + d

  console.log(result.toFixed(7))	
</script>

    <script type="ok" id="ch0103/08">

  var F = Number(prompt('请输入华氏温度（f >= -459.67）'))

  var C = 5 * (F-32) / 9
  
  console.log(C.toFixed(5))	
</script>

    <script type="ok" id="ch0103/09">

  var r = Number(prompt('圆的半径r（0 < r <= 10,000）'))

  var pi = 3.14159

  var D = 2 * r

  var C = 2 * r * pi  //var C = 2 * r * * pi 错误的

  var A = pi * r ** 2
  
  console.log(D.toFixed(4),C.toFixed(4),A.toFixed(4))	
</script>

    <script type="ok" id="ch0103/10">

 var r1 = parseFloat(prompt('r1电阻'))

 var r2 = parseFloat(prompt('r2电阻'))

 var R = 1/(1/r1 + 1/r2)
  
  console.log(R.toFixed(2))	
</script>

    <script type="ok" id="ch0103/11">

  var a = parseFloat(prompt('请输入a(a > 0)'))
 
  var b = parseFloat(prompt('请输入b(b > 0)'))

  var c = a % b
   
   console.log(c.toFixed(4))	
 </script>

    <script type="ok" id="ch0103/12">

  var r = parseFloat(prompt('请输入球的半径r(r > 0)'))

  var π = 3.14
 
  var V = 4 / 3 * π * r ** 3
 
  console.log(V.toFixed(2))	
 </script>

    <script type="ok" id="ch0103/13">

  var a = parseInt(prompt('请输入一个三位数'))

  var b = (a % 1000  - a % 100) / 100

  var c = (a % 100 - a % 10) / 10

  var d = a % 10
 
  console.log(''+d+c+b)	
 </script>

    <script type="ok" id="ch0103/14">

  var h = parseFloat(prompt('请输入圆桶的高度h(h > 0)'))

  var r = parseFloat(prompt('请输入圆桶的半径r(r > 0)'))
 
  var L = parseFloat((Math.PI * r ** 2 * h) / 1000) //Math.PI=π

  var backt_Num = Math.ceil(20 / L) //向上取整，半桶也是桶
//Math.max()Math.min()
//Math.floor(x)对x进行下取整
//Math.ceil(x)·对x进行上取整
//Math.trunc(x)保留x的整数部分
//x - x % - 1下取整
//x - x % + 1上取整
//(×·+·0.5)再下取整就是四舍五入

  
  console.log(backt_Num)	
 </script>

    <script type="ok" id="ch0103/15">

  var n = parseInt(prompt('请输入整数n'))

  var x = parseInt(prompt('请输入整数x'))
 
  var y = parseInt(prompt('请输入整数y(y <= n * x)'))

  var Apple_Num = parseInt((n * x - y) / x)

  console.log(Apple_Num)	
 </script>

    <script type="ok" id="ch0103/16">

  var Xa = Number(prompt('请输入(Xa,Ya)，的Xa(绝对值均不超过10000)'))

  var Ya = Number(prompt('请输入(Xa,Ya)，的Ya(绝对值均不超过10000)'))
 
  var Xb = Number(prompt('请输入(Xb,Yb)，的Xb(绝对值均不超过10000)'))

  var Yb = Number(prompt('请输入(Xb,Yb)，的Yb(绝对值均不超过10000)'))

  var length = ((Xb - Xa) ** 2 + (Yb - Ya) ** 2) ** 0.5
  //Math.sqrt(x)求x的平方根,square  root

  console.log(length.toFixed(3))	
 </script>

    <script type="ok" id="ch0103/17">
  debugger
  var X1 = Number(prompt('请输入(X1,Y1)，的X1'))

  var Y1 = Number(prompt('请输入(X1,Y1)，的Y1'))
 
  var X2 = Number(prompt('请输入(X2,Y2)，的X2'))

  var Y2 = Number(prompt('请输入(X2,Y2)，的Y2'))

  var X3 = Number(prompt('请输入(X3,Y3)，的X3'))

  var Y3 = Number(prompt('请输入(X3,Y3)，的Y3'))

  
  
  var a = ((X2 - X1) ** 2 + (Y2 - Y1) ** 2) ** 0.5

  var b = ((X3 - X2) ** 2 + (Y3 - Y2) ** 2) ** 0.5

  var c = ((X3 - X1) ** 2 + (Y3 - Y1) ** 2) ** 0.5

  var s = (a + b + c) / 2

  var A = (s * (s - a) * (s - b) * (s - c)) ** 0.5

  console.log(A.toFixed(2))	
 </script>
    <script type="ok" id="ch0103/18">

  var a1 = parseInt(prompt('请输入整数a1(-100 <= a1)'))

  var a2 = parseInt(prompt('请输入整数a2(a​2 <= 100)'))
 
  var n = parseInt(prompt('请输入整数n(0 < n <= 1000'))

  var add_Num = a2 - a1

  var aN = a1 + (add_Num * (n - 1)) //等差数列公式

  console.log(aN)	
 </script>

    <script type="ok" id="ch0103/19">
  var a = parseInt(prompt('请输入正整数A(1 <= A)'))
  var b = parseInt(prompt('请输入正整数B(B <= 50000)'))

  var c = a * b

  console.log(c)
</script>

    <script type="ok" id="ch0103/20">

  var b = parseInt(prompt('请输入正整数n(0 <= n < 31)'))

  var a = 2 ** b

  console.log(a)
</script>

    <script type="ok" id="ch0104/01">
  debugger
  var n = Number(prompt('n'))

  if (n > 0) {
    console.log('positive')
  } else {
    if (n == 0) {
      console.log('zero')
    } else {
      console.log('negative')
    }
  }

</script>

    <script type="ok" id="ch0104/02">
  var n = Number(prompt('n'))

  if (n >= 0) {
    console.log(n)
  } else {
    console.log(-n)
  }
</script>

    <script type="ok" id="ch0104/03">
  var n = Number(prompt('n'))

  if (n % 2 == 0) {
    console.log('even')
  } else {
    console.log('odd')
  }
</script>

    <script type="ok" id="ch0104/04">
  var n = prompt('随机输入一个字符')
  var m = n.charCodeAt(0) //charCodeAt(0)函数转换为ASCLL码
  if (m % 2 == 0) {
    console.log('NO')
  } else {
    console.log('YES')
  }
</script>

    <script type="ok" id="ch0104/05">
  var x = parseInt(prompt('随机输入一个整数（0<=x<2^32,-2^31<=y<2^31)'))
  var y = parseInt(prompt('随机输入一个整数（0<=x<2^32,-2^31<=y<2^31)'))
  if (x > y) {
    console.log('>')
  } else if (x < y){
    console.log('<')
  } else {
    console.log("=")
  }
</script>

    <script type="ok" id="ch0104/06">
  var x = parseInt(prompt('随机输入一个小于1000的正整数'))

  if (x >= 100 || x <= 9) {
    console.log('0')
  } else if (x < 100){
    console.log("1")
  }
</script>

    <script type="ok" id="ch0104/07">
  var x = parseInt(prompt('输入一幸运瓶盖数'))
  var y = parseInt(prompt('输入一鼓励瓶盖数'))

  if (x / 10 > 0 || y / 20 > 0) {
    console.log('1')
  } 
 
  if(x / 10 < 0 || y / 20 < 0){
    console.log("0")
  }
</script>

    <script type="ok" id="ch0104/08">
  var n = parseInt(prompt('输入一个整数n'))

  if (n % 3 ==0 && n % 5 == 0) {
    console.log('YES')
  } else if (n > 1000000 || n < -1000000 ) {
    console.log('n的范围是-1000000 < n < 1000000')
  } else {
    console.log("No")
  }
</script>

    <script type="ok" id="ch0104/09">
  var n = parseInt(prompt('输入一个整数n'))

  if (n % 3 != 0 && n % 5 != 0 && n % 7 != 0) {
    console.log('n')
  }else{
        if (n % 3 == 0) {
          console.log(3)
        } 
        if (n % 5 == 0) {
          console.log(5)
        } 
        if (n % 7 == 0) {
          console.log(7)
        }
      } 
  // if (n % 3 == 0 && n % 5 == 0 && n % 7 == 0) {
  //   console.log(3,5,7)
  // } else if (n % 3 == 0 && n % 5 == 0) {
  //   console.log(3,5)
  // } else if (n % 5 == 0 && n % 7 == 0) {
  //   console.log(5,7)
  // } else if (n % 3 == 0 && n % 7 == 0) {
  //   console.log(3,7)
  // } else if (n % 3 == 0) {
  //   console.log(3)
  // } else if (n % 5 == 0) {
  //   console.log(5)
  // } else if (n % 7 == 0) {
  //   console.log(7)
  // } else {
  //   console.log('n')
  // }


</script>

    <script type="ok" id="ch0104/10">
  var n = parseInt(prompt('输入你的语文成绩'))
  var m = parseInt(prompt('输入你的数学成绩'))

  // if ((n < 60 && m < 60) || (n >= 60 && m >= 60)) {
  //   console.log('0')
  // } else if ((n < 60 && m >= 60) || (n >= 60 && m < 60)) {
  //   console.log('1')
  // }
  
  if ((n >= 60 && m < 60) || (n < 60 && m >= 60)) {
    console.log('1')
      } else {
        console.log('0')
      }

</script>

    <script type="ok" id="ch0104/11">
  var n = parseInt(prompt('输入看展日期'))
  
  if (n == 1 || n == 3 || n == 5) {
    console.log('NO')
  } else if (n <= 0 || n > 7){
    console.log('请输入1-7表示星期')
  } else{
    console.log("YES");
  }
</script>

    <script type="ok" id="ch0104/12">
  var n = parseInt(prompt('输入距离'))
  
  var walk = n / 1.2

  var bike = n / 3 + 23 +27

  if (walk < bike) {
    console.log('Walk')
  } else if (walk > bike){
    console.log('Bike')
  } else {
    console.log("ALL");
  }
</script>

    <script type="ok" id="ch0104/13">
  var N = parseFloat((prompt('输入N（0<=N < 20）')))

  // if (N >= 0 && N < 5) {
  //   y = -N + 2.5
  //   console.log(y.toFixed(3))
  // } else if (N >= 5 && N < 10){
  //   y = 2 - 1.5 * (N - 3) * (N - 3)
  //   console.log(y.toFixed(3))
  // } else if (N >= 10 && N < 20){
  //   y = N / 2 - 1.5
  //   console.log(y.toFixed(3));
  // }

  //简化版,题目给了条件就不用考虑。一般来说先判断更小的条件再判断更大的条件
  if (N < 5) {
    y = -N + 2.5
    console.log(y.toFixed(3))
  } else if (N < 10){
    y = 2 - 1.5 * (N - 3) * (N - 3)
    console.log(y.toFixed(3))
  } else {
    y = N / 2 - 1.5
    console.log(y.toFixed(3));
  }
</script>

    <script type="ok" id="ch0104/14">
  debugger
  var N = parseInt((prompt('输入重量')))
  var Y = (prompt('加急输入y,不加急输入n'))
  var much = 8
  var add = 5
  
  if (N > 1000) {    
    m = much + Math.ceil(((N - 1000) / 500)) * 4    
  } 

 if (Y == 'y') { 
  add = m + add
  console.log(add)
 }

 
  // if (N <= 1000) {
  //   m = 8
  //   console.log(m)
  // } else if (N <= 1000 && Y == 'y'){
  //   m = 8 + 5
  //   console.log(m)
  // } else if (N > 1000 && Y != 'y'){
  //   m = 8 + Math.ceil(((N - 1000) / 500)) * 4 //超重部分向上取整
  //   console.log(m)
  // } else if (N > 1000 && Y == 'y'){
  //   m = 8 + Math.ceil(((N - 1000) / 500)) * 4 + 5
  //   console.log(m)
  // }  
</script>

    <script type="ok" id="ch0104/15">
      
  var a = parseInt(prompt('输入第一个整数'))
  var b = parseInt(prompt('输入第二个整数'))
  var c = parseInt(prompt('输入第三个整数'))
  var max = a

  if (max < b){
    max = b
  }
  
  if (max < c){
    max = c
  }

  console.log(max);
</script>

    <script type="ok" id="ch0104/16">
  var a = parseInt(prompt('输入第一条边'))
  var b = parseInt(prompt('输入第二条边'))
  var c = parseInt(prompt('输入第三条边'))

  if(a + b > c && a + c > b && c + b >a){
    console.log('yes');
  }else{
    console.log('no');
  }
  

</script>

    <script type="ok" id="ch0104/17">
  var a = parseInt(prompt('输入年份'))

  if ((a % 4 === 0 && a % 100 != 0 )|| a % 400 === 0){
    console.log('Y')
  }else if(a <= 0 && a >= 300){
    console.log('范围是0<a<300') 
  }else{
    console.log('N')
  }
</script>

    <script type="ok" id="ch0104/18">
  var x = parseInt(prompt('输入坐标x'))
  var y = parseInt(prompt('输入坐标y'))

  //C = 2

  if (x <= 2 && y <= 2){
    console.log('yes')
  }else{
    console.log('no')
  }
</script>

    <script type="ok" id="ch0104/19">
  var x = parseInt(prompt('输入一个整数'))
  var y = parseInt(prompt('输入另一个整数'))
  var z = prompt('输入运算符号')


  if (z == '/' && y == 0){
    console.log('Divided by zero!')
  }else if(z == '+'){
    console.log(x + y)
  }else if(z == '-'){
    console.log(x - y)
  }else if(z == '*'){
    console.log(x * y)
  }else if(z == '/'){
    console.log(x / y)
  }
</script>

    <script type="ok" id="ch0104/20">
  var a = parseFloat(prompt('输入第一个浮点数'))
  var b = parseFloat(prompt('输入第二个浮点数'))
  var c = parseFloat(prompt('输入第三个浮点数'))

  var x1 = ((-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a)).toFixed(5)
  var x2 = ((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a)).toFixed(5)

  var Real_Part = (-b/(2*a)).toFixed(5)
  var Imaginary_Part = (Math.sqrt(4*a*c - b*b) / (2 * a)).toFixed(5)

  if (b**2 == 4*a*c){ //delta == 0
    console.log('x1=x2='+x1)
  }else if (b**2 > 4*a*c) { //delta > 0
    console.log('x1'+'='+x1+';'+'x2'+'='+x2)
  }else if (b**2 < 4*a*c) { //delta < 0
    console.log('x1'+'='+Real_Part+'+'+Imaginary_Part+'i'+';'+'x2'+'='+Real_Part+'-'+Imaginary_Part+'i')
  }
</script>

    <script type="ok" id="ch0104/21">
  var n = parseInt(prompt('输入苹果数'))
  var x = parseInt(prompt('输入虫子吃小时数'))
  var y = parseInt(prompt('输入小时数'))

  var a = Math.floor(n - y / x)

  console.log(a)

</script>

    <script type="ok" id="ch0105/01">
  debugger
  var n = Number(prompt('人数'))
  var sum = 0 // 记录所有人的年龄之和
  var age

  var c = 0
  while (c < n) {
    age = Number(prompt('年龄'))
    sum = sum + age
    c = c + 1
  }

  console.log(  (sum / n).toFixed(2)  )

</script>

    <script type="ok" id="ch0105/02">
  var s = 0
  var sum = 0

  while(s < 12){
    s = s + 1
    var a = Number(prompt('输入'+s+'月的结余'))
    sum = a + sum 
  }

  var averg = (sum  / 12).toFixed(2)

  console.log('$'+averg)
</script>

    <script type="ok" id="ch0105/03">

  var s = Number(prompt('输入样本容量'))
  var agent = 0
  var sum = 0

  while(s > agent){
    test = Number(prompt('输入样本数据'))
    sum = test + sum 
    
    agent = agent + 1
  }

  var averg = (sum / s).toFixed(4)
  
  console.log(averg)
</script>

    <script type="ok" id="ch0105/04">

  var s = Number(prompt('输入一个整数n'))
  var agent = 0
  var sum = 0

  while(s > agent){
    test = Number(prompt('输入整数'))
   
    sum = test + sum 
    agent = agent + 1
  }
  var averg = (sum / s).toFixed(5)
  console.log(sum,averg)
</script>

    <script type="ok" id="ch0105/05">

  var s = Number(prompt('输入参加考试的人数'))
  var agent = 0
  var max = 0
  var agent2 = 0

  while(s > agent){
    test = Number(prompt('输入这个学生的成绩'))
    agent2 = test 
    if (max < test) {
      max = agent2
    }
    agent = agent + 1
  }
  
  console.log(max)
</script>

    <script type="ok" id="ch0105/06">

  var s = Number(prompt('输入序列个数'))
  var agent = 0
  var max = 0
  var min = 0 //1000 有可能后面的数大
  var agent2 = 0

  while(s > agent){
    test = Number(prompt('输入整数'))
    agent2 = test 
    if (max < test) {
      max = agent2
    }
    if (min > test) {
      min = agent2
    }
    agent = agent + 1
  }
  
  console.log(max - min)
</script>

    <script type="ok" id="ch0105/07">
//太累赘？？？似乎没有
  var s = parseInt((prompt('输入比赛天数')))
  var agent = 0
  var sum = 0

  var goden = 0
  var silver = 0
  var copper = 0

  while(s > agent){
    test = parseInt((prompt('输入金牌数')))
    test2 = parseInt((prompt('输入银牌数')))
    test3 = parseInt((prompt('输入铜牌数')))

    goden = goden + test
    silver = silver + test2
    copper = copper + test3

    agent = agent + 1
  }

  sum = goden + silver + copper

  console.log(goden,silver,copper,sum);
</script>

    <script type="ok" id="ch0105/08">
//太累赘
  var s = parseInt(prompt('输入n边形的边'))
  var s1 = 1
  var agent = 0
  var sum = 0


  while(s > agent){
    deg = parseInt(prompt('输入' + s + '边形的第' + s1 + '内角度数'))
    sum = deg + sum 
    if (s1 < s){
        s1 = s1 + 1
    }
    agent = agent + 2
  }

  var sumdeg = (s - 2) * 180 - sum
  
  console.log(sumdeg)
</script>

    <script type="ok" id="ch0105/09">

  // var m = parseInt(prompt('输入m'))
  // var n = parseInt(prompt('输入n'))

  // var agent = n
  // var agent2 = 0

  // var sum = 0

  // while(n > agent){

  //   agent = n + 1
    

  //   if(m % 2 != 0){
  //     sum = sum + m
  //   }
    
  //   m = m + 1
  //   agent2 = agent2 + 1
  // }
  
  // console.log(sum)
  // var m = parseInt(prompt('输入m'))
  // var n = parseInt(prompt('输入n'))

  // var agent = m //n
  // var sum = 0

  // while (agent <= n){
  //   if(m % 2 != 0){
  //     sum = sum + agent
  //   }
  //   agent = agent + 1
  // }

  // console.log(sum);

  //太累赘，最优不用循环的是用等差数列
  var m = parseInt(prompt('输入m'))
  var n = parseInt(prompt('输入n'))
  var sum = 0
  
  var current = m  //什么时候结束
  while (current <= n) { //到N结束
    if (current % 2 != 0) {
      sum += current
    }
    current++
  }

  console.log(sum)
</script>

    <script type="ok" id="ch0105/10">
  var m = parseInt(prompt('输入m'))
  var n = parseInt(prompt('输入n'))

  var sum = 0
  var current = m

  while (current <= n) {
    if (current % 17 == 0) {
      sum += current
    }
    current++
  }

  console.log(sum)
</script>

    <script type="ok" id="ch0105/11">
  var k = parseInt(prompt('输入k'))
  var one = 0
  var five = 0
  var ten = 0
  var current = 0

  while(k > current){
    a = parseInt(prompt('输入正整数'))

    if (a == 1) {
      one++
    }

    if (a == 5) {
      five++
    }

    if (a == 10) {
      ten++
    }
    current++
  }

  console.log(one,five,ten);
</script>

    <script type="ok" id="ch0105/12">
  var N = parseInt(prompt('输入N,N<=100'))
  var m = parseInt(prompt('输入m'))

  var current = 0
  var sum = 0

  while(N > current){
    a = parseInt(prompt('输入正整数'))
    if (m == a) { //类型不一样三个等号？
      sum++
    }
    current++
  }

  console.log(sum);
</script>

    <script type="ok" id="ch0105/13">
  var a = parseInt(prompt('输入a,-1000000<=a<=1000000'))
  var n = parseInt(prompt('输入n,1<=n<=10000'))

  var current = 0
  var result = 1

  while(n > current){
  
    //a = a*a,公式问题 
    result = result * a
    current++
  }

  console.log(result);
</script>

    <script type="ok" id="ch0105/14">
  var x = parseInt(prompt('输入x人口基数,1<=x<=100'))
  var n = parseInt(prompt('输入n年份,1<=n<=10000'))

  var current = 0
  var sum = x

  while(n > current){
  
    sum = sum * 1.001 //(1+1%，百分比计数问题)
    current++
  }

  console.log(sum.toFixed(4));
</script>

    <script type="ok" id="ch0105/15">
  var R = parseInt(prompt('符合利率,R'))
  var M = parseInt(prompt('M'))
  var Y = parseInt(prompt('输入Y年份'))

  var current = 0
  var sum = M

for (let index = 0; index < Y; index++) {
  
  sum = sum * (1 + R / 100)
  
}

  console.log(Math.trunc(sum));//parseInt(sum)
</script>

<script type="ok" id="ch0105/16">
//可以简化
  var N = parseInt(prompt('年薪'))
  var K = parseInt(prompt('房价增长'))
  var NSumony = 0
  var current = 1 //年份计数
  var sumHouse = 200

for (let index = 0; index < 20; index++) {
  
  
  NSumony = N * current //NSumony += N                

  if (NSumony >= sumHouse){ // >= 相等的钱也可以买房子
    console.log(current)
    break
  }

  sumHouse = sumHouse * (1 + K / 100) //根据答案倒退第一年房价是不涨价的。问题所在,第一年房价不涨,不能放在循环体最前面
  current++  // 跳出后就不用再次增加 
}

if (current > 20) { //不需要在循环体内
    console.log('Impossible')
    //不需要break,会自动跳出
  }

</script>

<script type="ok" id="ch0105/17">
  var k = parseInt(prompt('输入k'))
 
  var current = 2 // 从第三位开始计算，为0自然结果不对
  var a = 1
  var b = 1
  var c = 0
  //可以优化从a=1 b=0,or 非常了解数列本质
  //忽视了！要是先算第一位和第二位的话，这个就不成立所以
  if(k<3){
    console.log(1);
  }else{
  while(k > current){ 
  
    c = a + b 
    a = b //对逻辑不敏感，流程图已经画出来了的但是没发现，替换
    b = c 
    current++
  }}

  console.log(c)
</script>

    <script type="ok" id="ch0105/18">
  var n = parseInt(prompt('输入n组实验'))

  var a = parseInt(prompt('鸡尾酒疗法总病例数'))
  var b = parseInt(prompt('鸡尾酒疗法有效病例数'))
  
  var x =  b / a //已经是0.05不需要 / 100

for (let index = 1; index < n; index++) {
  var c = parseInt(prompt('新疗法总病例数'))
  var d = parseInt(prompt('新疗法有效病例数'))
  
  var y = d / c //已经是0.05不需要 / 100

   
  if ((y - x) > 0.05) {
    console.log('better')
  }else if ((x - y) > 0.05) { //其实从题目的逻辑可以推导出来，在逻辑转换上要注意看错条件了，干
    console.log('worse');
  }else{
    console.log('same');
  }
}

</script>
    <script type="ok" id="ch0105/19">
      //可以简化，上船下船直接乘以即可
  var n = parseInt(prompt('输入屋顶数'))
  var SumTime = 0
  var MoveTime = 0
  var OnTime = 0
  var DownTime = 0

for (let index = 0; index < n; index++) {
  var x = parseInt(prompt('输入屋顶的x坐标'))
  var y = parseInt(prompt('输入屋顶的x坐标'))
  var z = parseInt(prompt('输入救援人数'))
  
  MoveTime = Math.sqrt(x * x + y * y) / 50 * 2
  OnTime = z
  DownTime = z * 0.5

  SumTime = Math.ceil(MoveTime + OnTime + DownTime + SumTime)
}
  console.log(SumTime);
</script>

<script type="ok" id="ch0105/20">
//   //这样算似乎有精度差
//   var h = Number(prompt('输入球的初始高度'))
//   //这样写似乎有些问题，相当于球是从地上蹦起来的
//   var SumH = 20 //本身高度也要算


// for (let index = 0; index < 10; index++) {
//   h = h / 2

//   SumH = 2 * h + SumH //弹跳两次，计算两次
// }
// console.log(SumH.toFixed(6)) //精度问题
// console.log(h.toFixed(6))

var h = +prompt()
//总高度
var totalRun = 0
//存储每次跳一半的高度
var halfH = h
for (let i = 0; i < 10; i++) {
  totalRun = totalRun + halfH * 2
  halfH = halfH / 2 
}

//减去初始高度
totalRun = totalRun - h
console.log(totalRun.toFixed(4),halfH.toFixed(7));
</script>

    <script type="ok" id="ch0105/21">
  var N = parseInt(prompt('输入一个正整数N'))
  var a,b = 0

  while(N != 1){
    if (N % 2 == 0){
      a= N + '/2='
      N = N / 2 
      console.log(a + N)
    } else {
      b = N+'*3'+'+1='
      N = N * 3 + 1 
      console.log(b + N)
    }
  }

  if(N == 1){} //可以不要，while等于1会直接结束
    
  
  console.log('End');

</script>

    <script type="NO" id="ch0105/22">
    var motherM = 0 //在mother那里的存款
    var MySUMouth = 0
    var MySUM = 0
    var MyMoney = 0 //手里的钱

  for (let index = 0; index < 12; index++) {
    var x = parseInt(prompt('输入第'+ (index + 1) +'月的预算'))
    MyMoney += 300 //每个月发300块


    while (x >= 100) {//在mother那里的存款
      motherM += 100 
      
      x += MySUMouth

   // MySUM = motherM * 1.2
  
  }
}

  console.log(MySUM + x);
</script>

<script type="ok" id="ch0105/23"> //应该有改进的方法，从n下手？
var m = parseInt(prompt('药品总量m'))
var n = parseInt(prompt('取药人数n(0 < n <= 100)'))
var No = 0 //取到药的人数

for (let index = 0; index < n; index++) {
  var num = parseInt(prompt('第'+ (index + 1) + '位' + '取药数量'))
  
  if (num < m) {
    m = m - num
    No++   
    continue
  }
}

console.log(n - No);
</script>

<script type="ok" id="ch0105/24">
var n = parseInt(prompt('n'))//小时量一次
var ok = 0  //总次数
var ook = 0 //连续次数


for (let index = 0; index < n; index++) {
  var Systolic = parseInt(prompt('第'+ (index + 1) + '次' + '收缩压'))
  var Diastolic = parseInt(prompt('第'+ (index + 1) + '次' + '舒展压'))

  if (Systolic >= 90 && Systolic<=140 && Diastolic >= 60 && Diastolic<=90) {
    ok++ //增加正常次数

    if (ok > ook) {
        ook = ok //连续次数
      }
    
  }else{
    ok = 0 //重置连续次数
  }
}
console.log(ook);
</script>

<script type="ok" id="ch0105/25">
//明确了三位数,i就是所需的三位数
for (let i = 1; i <999; i++) {
//7
      var a7 = i % 7 //7进制个位上的数，或者说取的是十进制的个位数
      var b7 = (i - a7) /7 % 7 //7进制十位上的数
      var c7 = (i - a7 - b7 * 7) /7 /7 % 7 //7进制百位上的数
//7
var a9 = i % 9 //9进制个位上的数，或者说取的是十进制的个位数
      var b9 = (i - a9) /9 % 9 //9进制十位上的数
      var c9 = (i - b7 - b9 * 9) /9 /9 % 9 //9进制百位上的数   

if (a7 == a9 && b7 == b9 && c7 == c9) {
  console.log(i);
  console.log(''+a7+b7+c7);
  console.log(''+a9+b9+c9);
  break
}   
}

</script>

<script type="ok" id="ch0105/26">
var n = parseInt(prompt('输入4位数的个数n<=100'))
var current = 0 //计数
for (let index = 0; index < n; index++) {
  var m = parseInt(prompt('输入4位数'))
  var a = m % 10 //个位
  var b = (m % 100 - m % 10) / 10 //十位
  var c = (m % 1000 - m % 100) / 100 //百位
  var d = (m - m % 1000) / 1000 //千位
  if ((a - d - c -b)>0) {
    current++
  }
}
console.log(current);
</script>

<script type="ok" id="ch0105/27">
//死循环的时候要是知道,下面这样可能会存在潜在死循环while (true)
// var K = parseInt(prompt('输入整数K（1<=k<=15）'))  
// var Sn = 0
// //首项n
// var n = 1 
// var current = 0
// while (true) {    //for (var i = 1; ;i++){} 也可以
//   Sn = Sn + 1 / n
//   n++
//   if (Sn > K) {
//     break
//   }
// } 
// console.log(n-1);
var K = +prompt('输入整数K（1<=k<=15）')
var Sn  = 0
for (var i = 1; ;i++){
  Sn += 1 / i
  if (Sn > K) {
     break 
}
}
console.log(i)
</script>

<script type="ok" id="ch0105/28">
  var n = parseInt(prompt('输入整数1到100000000之间'))
  //用do while来表示为0时的情况
  do {
    //分离出每一个数再相减
    var digit = n % 10
    console.log(digit);
    n = (n - digit) / 10 //number = (n - digit) / 10 
  } while (n > 0); //number > 0 这样写始终会大于零
//下面这样写太麻烦，没必要
/*var number = parseInt(prompt('输入整数1到100000000之间'))

// 将数字转换为字符串
var numberString = number.toString()

// 存储结果字符串
var result = ''

// 从个位开始遍历字符串的每一个字符,反向遍历
for (var i = numberString.length - 1; i >= 0; i--) {
    result += numberString[i]
}

console.log(result);*/
</script>

<script type="ok" id="ch0105/29">
  //28的思路做，但我想不出来
  var n = +prompt('-1,000,000,000 ≤ N≤ 1,000,000,000')
  //用于数字的重组,同时又兼顾了等于0时的情况
  var result = 0
  //取正数or负数
  var sign = 1 
  if (n<0) {
    sign = -1
    n = -n
  }

  while (n > 0) {
    var dighit = n % 10
    n = (n - dighit) / 10
    result = result * 10 +dighit
  }

  console.log(result * sign);



  /*var number = parseInt(prompt('输入整数1<=n<=100000000'))

  //判断±并添加负号
  if (number < 0) {
    var operator = -1
  }else{
    var operator = 1
  }
  // 将数字转换为字符串
  var numberString = number.toString()
  
  // 存储字符串
  var result = ''
  
  // 从个位开始遍历字符串的每一个字符,反向遍历
  for (var i = numberString.length - 1; i >= 0; i--) {
      result += numberString[i]
  }

  //转换数字,去掉0
  var x = parseInt(result)

  //题目要求是数字
  console.log(operator * x); */
  

  
  </script>
  <script type="ok" id="ch0105/30">
    var m = parseInt(prompt('输入整数m,1<m<100000'))
    var k = parseInt(prompt('输入整数k,1<k<5'))

    //转换为字符串,toString(),函数调用“ . ”
    var mString = m.toString()
    //存储字3有几个
    var tree = 0

    for (let index = 0; index < mString.length; index++) {
      
      if (mString[index] == '3') {
        parseInt(tree++)
      }
    }

    if (m % 19 == 0 && tree == k) {
      console.log('YES');
    }else{
      console.log('NO');
    }
  </script>

  <script type="NO" id="ch0105/31">
    var N = parseInt(prompt('N盏灯,N<5000'))
    var M = parseInt(prompt('M人'))

    //创建N长度的数组{array()}以存储{fill()}灯的状态true开、false关
    var lights = new Array(N).fill(true)

    //循环模拟第一个人的操作
  for (let i = 0; i < Array.length; i++) {
    lights[i] = false
  }
    //循环模拟从第二个人开始的操作
  for (let person = 2; person <= M; person++) { //要关多少盏灯，少了1，所以<=M
    for (let i = person - 1; i < N; i += person ) { //有多少人来关灯。想不到，真想不到

      lights[i] = !lights[i] 
    } 
  }  
  </script>

  <script type="ok" id="ch0105/32">   
        var N = parseFloat(prompt('输入n,N<=30'))
        //q1
        var a = 2
        //p1
        var b = 1
        //存储分数
        var d = 0

        for (let i = 1;i <= N;i++) {
          d += a / b
          var c = a + b 
          b = a 
          a = c  
        }

        console.log(d.toFixed(4));
  </script>

<script type="ok" id="ch0105/33">
 
  var n = parseFloat(prompt('输入n,1<=N<=1000'))

  //存储表达式的值
  var x = 0

  for (let i = 1; i <= n; i++) {
  //计算n序列的值
  var m = (-1) ** (i - 1) * (1 / i)
  //存储表达式的值,要先在循环体外声明  
  var x = m + x
    
  }
  console.log(x.toFixed(4));
</script>

<script type="ok" id="ch0105/34">
  
  var n = parseInt(prompt('输入n,1<n<12'))
  //存储阶乘的和
  var SumN = 0
  //存储阶乘的值
  var c = 0
  //0! == 1,1! == 1
  var a = 1

  for (let i = 1; i <= n; i++) {
      c = a * i
      a = c
      SumN += a
    }

    console.log(SumN);

    
  
</script>

<script type="ok" id="ch0105/35">

  var n = parseInt(prompt('输入n,2<=n<=15'))
  //存储1/n!的和
  var SumN = 0
  //存储阶乘的值
  var c = 0
  //0! == 1,1! == 1
  var a = 1

  for (let i = 1; i <= n; i++) {
      c = a * i
      a = c
      SumN += 1 / a
    }

  console.log((1 + SumN).toFixed(10));  
</script>

<script type="ok" id="ch0105/36">
var x = parseFloat(prompt('输入x'))
var n = parseInt(prompt('输入正整数n,<=1000000'))
var sum = 0

for (let i = 0; i <= n; i++) {

  sum += parseFloat(x ** i)
  
}

console.log(sum.toFixed(2));
</script>

<script type="NO" id="ch0105/37">
  debugger0
  var M= parseFloat(prompt('输入M体力值'))
  var N= parseFloat(prompt('输入N战斗力'))
  var X= parseFloat(prompt('输入X个能量元素'))

  for (let i = X; i >= 1; i--) {
   
    N = M / N + N
    
  }
console.log(N);
</script>

<script type="NO" id="ch0105/38">

</script>

<script type="ok" id="ch0105/39">
 //思路不一样，每一个位数取出来比较
  var n = parseInt(prompt('输入n'))

  var sum = 0

  for (let i = 1; i <= n; i++) { //i相当于n的值
    var o = i.toString()
      //是否有7,内层定义。在外层的话不会改变布尔值
  var hasSeven = false
   for (let p = 0; p < o.length; p++) {
    //为7,hasSeven = true ，作为标记，然后跳出进行下一判断
    if (o[p] == '7') {//===
      hasSeven = true
      break
    }

  }
  //不为7，让hasSeven重新为false 且满足% 7 != 0的条件
  if (!hasSeven && i % 7 != 0) {
      
      
      //sum *= i sum = sum + i * i
      sum += i * i
    
  }
}
 

  console.log(sum);

</script>

<script type="ok" id="ch0105/40">
  
  var n = parseInt(prompt('输入n,1<=n<=10000'))
  //存储是否有1
  var one = 0
  //遍历n
  for (let i = 1; i <=n; i++) {
    //转为字符串,i才是数字
    var nString = i.toString()
    //遍历字符串
    for (let a = 0; a < nString.length; a++) {
      //是否有1
      if (nString[a] == '1') {
        one++
      }  
    }
  }
  console.log(one);
</script>

<script type="ok" id="ch0105/41">
  var L = parseInt(prompt('输入[L,R]的L'))
  var R = parseInt(prompt('输入[L,R]的R'))
  //存储是否有1
  var two = 0
  //遍历n
  for (let i = L; i <=R; i++) {
    //转为字符串,i才是数字
    var nString = i.toString()
    //遍历字符串
    for (let a = 0; a < nString.length; a++) {
      //是否有1
      if (nString[a] == '2') {
        two++
      }  
    }
  }
  console.log(two);
</script>

<script type="ok" id="ch0105/42">
  var hight = parseInt(prompt('输入矩形的高（3<=hight<=10）'))
  var wight = parseInt(prompt('输入矩形的宽（5<=wight<=10）'))
  var operatorArt = prompt('输入画图的矩形符号')
  var full = parseInt(prompt('0空心，1实心'))

    //存储符号
    var operatorTable = ''

  for (let i = 1; i <= hight; i++) {
    for (let j = 1; j <= wight; j++) {
      //何种情况下有符号填充实心、第一位和最后一位
      if (full == 1 || i == 1 || j == 1 || i == hight || j == wight) {
        operatorTable += operatorArt
      } else {
        //否则就没有，用空格占位
        operatorTable += ' '
      }
      }
      operatorTable += '\n'    
    // console.log(operatorTable += '\n') , 这相当于把每一次增加的行数都打印出来
  }
  //取最后一次完成的图形
   console.log(operatorTable)
  
</script>


<script type="ok" id="ch0105/43">
  //似乎要对这个质数有理解才能写出来
var n = +prompt('输入n')
for (let i = 2; i < n; i++) {
  if (n % i == 0) {
    var answer = n / i
  console.log(answer);
  break
  }
}
</script>
<script type="ok" id="ch0105/44">
  var n = +prompt('输入n')
  var count = 0

  //因为不知道到哪一个结束，需要一直数数,从2开始数
  for (let x = 2; ; x++) {
  //是质数
  var isPrime = true
  //在这里质数是y
    for (let y = 2; y <= x / 2; y++) {
        if (x % y == 0 ) {
          isPrime =  false
          //跳出循环
          break
      } 
    }
  
  
  if (isPrime) {
    //是质数就记下来
    count++
    //第n小的质数
    if (count == n) {
      console.log(x);
      //跳出循环
      break
    }
}
  }

</script>
<script type="NO" id="ch0105/45"></script>


<script type="ok" id="ch3/01">
  //判断x是否是整数or用函数Number.isInteger(x)
  var isInteger = function(x){
    //x%1取出小数部分，减去小数部分做比较
    if (x === x - (x % 1)) {
      return true
    }else{
      return false
    }
  }
  //对正整数n，如果用2到 之间的所有整数去除，均无法整除，则n为质数。
 function isPrime(x) {
    //素数是一个大于1的自然数(也不是浮点数)
    if (x <= 1 || !isInteger(x)) {
      return false
    }

    //因为2和3的根是小于2的无法进入循环，要单独拿出来
    if (x == 2 || x == 3) {
      return true
    }
    //i <= x / 2也可以
    for (let i = 2; i <= Math.sqrt(x); i++) {
        if (x % i == 0 ) {
          return false
      //把else放在这里的话可能在第一次检查后就返回 'true'，即使数字不是素数
      // }else{ 
      //   return true
      // }  
    }
      //等循环体完全结束再返回true,保证一个不漏
      return true

    }
  }
console.log(素数(3)); 
</script>
<script type="ok" id="ch3/02">//可以与39联动
  function aboutSeven(x) {

    //是否与7无关返回false
    if (x % 7 != 0 || x == 0) {
      return false
    }else{
    //是否与7有关返回true
    while (true) {
    //为正数  
    if (x > 0) {
      //取出个位数
      var ge = x % 10
        if (ge == 7) {
          return true
          break
        }
        //去除已经取出来的个位数
        x = (x - ge) / 10
    } else {
      //为负数 
            //取出个位数
            var ge = x % 10
            if (ge == -7) {
              return true
              break
            }
            //去除已经取出来的个位数
            x = (x + ge) / 10
    }  
 
  } 
  //循环完了也没有值，说明无关
  return false
}
}
console.log(aboutSeven(-7));
  
</script>

<script type="ok" id="narcissistic">
  //严格来说3位数的3次幂数才称为水仙花数,但是这里的水仙花是，每个数字的宽度次幂的和等于这个数
 
    //计算宽度
  //   var count = 0
  //   while (x > 0) {
  //     var ge = x % 10
  //     x = (x - ge) / 10
  //     count++
  //   }
  //   if (count < 3) {
  //     return false
  //   }else{
  //     return true
  //   }
  function flowerWidth(x) {
  var width = 0
  do{
    var ge = x % 10
    x = (x - ge) / 10
    width++ 
  }while(x > 0)
  return width
  }

  function Flower(x) {
    var width = flowerWidth(x)
    var sum = 0
    var y = x
    while (x > 0) {
      var ge = x % 10
      sum += ge ** width
      x = (x - ge) / 10
    }
    //x一直在变运行到这里已经变成0了
    if (sum === y) {
      return true
    }else{
      return false
    }
  } 
</script>

<script type="ok" id="narcissistics">
    function flowerWidth(x) {
  var width = 0
  do{
    var ge = x % 10
    x = (x - ge) / 10
    width++ 
  }while(x > 0)
  return width
  }

  function Flower(x) {
    var width = flowerWidth(x)
    var sum = 0
    var y = x
    while (x > 0) {
      var ge = x % 10
      sum += ge ** width
      x = (x - ge) / 10
    }
    //x一直在变运行到这里已经变成0了
    if (sum === y) {
      return true
    }else{
      return false
    }
  }

  
    for (let i = 0; i <= 1000; i++) {
      if (Flower(i)) {
          console.log(i);
      }
    }
</script>
<script type="ok" id="complete-number">
  function iscompletenumber(x) {
    //存储和,1是任何数的因子
    var sum = 1
    //从循环体拿出来，避免重复
    var sqrt_x = Math.sqrt(x)
    //1是任何数的因子。
    //既然能整除，那么因子就不会只有一个Math.sqrt(x)
    for (let i = 2; i < sqrt_x; i++) {
      //是因数%才能等于0
      if (x % i == 0) {
        //i是因子，既然能除尽。那么一定有另一个因子x / i，所以一起加了
        sum += i + x / i
      } 
    }
    //如果能被整开平方根，就说明一定有因子，那就要加上
    //Number.isInteger()检测是不是整数
    if (Number.isInteger(sqrt_x)) {
      sum += sqrt_x
    }
    //sum == x 本身就返回布尔值，不用写if
    return sum == x  
    }
  
</script>
<script type="ok" id="complete-numbers">
  function iscompletenumber(x) {
    //存储和,1是任何数的因子
    var sum = 1
    //1是任何数的因子，且不包含自身
    for (let i = 2; i < x; i++) {
      //是因数%才能等于0
      if (x % i == 0) {
        sum += i
      } 
    }
    //sum == x 本身就返回布尔值，不用写if
    if (sum == x) {
      return sum
    } 
    }

    for (let i = 1; i < 1000; i++) {
      console.log(iscompletenumber(i));
    }
  
</script>
<script type="ok" id="prime">
  
  function isPrime(x) {
    //因为%为0都有两个因子，所以大于n/2的数不可能被除尽（出它自身以外）
    //<= sqrt_x = Math.sqrt(x)
    for (let i = 2; i <= x / 2; i++) {
      if (x % i == 0) {
        return false
      } //else{不能在这里，不然会直接跳出来
    }
       return true
  }  
</script>
<script type="ok" id="primes">
  function isPrime(x) {
     //因为%为0都有两个因子，所以大于n/2的数不可能被除尽（出它自身以外）
     //<= sqrt_x = Math.sqrt(x)
    for (let i = 2; i <= x / 2; i++) {
      if (x % i == 0) {
        return false
      } 
    }
       return true
  } 
  for (let i = 2; i < 100; i++) {
    if(isPrime(i)){
      console.log(i);
    } 
  }
  
</script>

<script type="ok" id="???">
  //先取出来再加上去，然后对比。对比的是数字不是字符串
function isItob(x) {
  var reverse = 0
  var y = x
  while (x > 0) {
    var ge = x % 10
    reverse = reverse * 10 + ge
    x = (x - ge) / 10
  }
  //x会变化，需要用另一个值来存储
    return reverse == y
}
</script>
<script type="ok" id="weekday1">
  //W= (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400) % 7 
  //Kim larsen calculation formula Zeller
  function weekday(y,m) {
    //1、2月是13，14,年份也要-1
    if (m < 3) {
      m += 12
      y--
    }
    //星期一
    var d = 1
    //Zeller公式需要整除运算，使用Math.floor()
    //var W = (d+2*m+Math.floor(3*(m+1)/5)+y+Math.floor(y/4)-Math.floor(y/100)+Math.floor(y/400) )% 7
    var W = (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)% 7
    //星期一是 0
    return parseInt(W)
  }
</script>
<script type="ok" id="weekday">
  //从公元前到现在这一天的综合 % 7 +1就是星期几
debugger
  //闰年366，平年365。参数名字还是要非常明显才行
  function isLeapYear(year) {
    if (year % 400 == 0) {
      return true
    }else if (year % 100 == 0) {
      return false
    }else if (year % 4 == 0) {
      return true
    }else{  
      return false
    }
  }

  //月份30/31,2月28、29。某年某月的天数，后面要计算每个月多少天。虽然所在年不算，但是还是要计算是否是闰年。同时可以把参数y传入years(y)
  //参数名字还是要非常明显才行
  function getMouthDays(year,mouth) {
    if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) {
      return 31
    }else if (mouth == 4 || mouth == 6 || mouth == 9 || mouth == 11) {
      return 30
    }
    
    if (isLeapYear(year) && mouth == 2) {
      return 29
    }else{
      return 28
    }
  }
  //公元元年=1
  function weekday(year,mouth) {
    
    var totalDay = 0
    for (let y = 1; y < year; y++) {
      if (isLeapYear(y)) {
        totalDay += 366
      }else{
        totalDay += 365
      }  
    }
  //这里计算月份多少天错了  
  // if (mouth(m)) {
  //   mouthDay += 31
  // }else{
  //   mouthDay += 30
  // }

  //计算有多少月。1 ~ 前一个月。当月的第一天要 +1
  for (let m = 1; m < mouth; m++) {
    //这里应该传的是m而不是mouth
    totalDay += getMouthDays(year,m)  
  }
   

  //计算星期几,1 ~ 7。还要＋1  
  var week = (totalDay % 7) 
  return week
  }

  weekday(2024,7)
</script>

<script type="ok" id="itob">//可以优化
  //先取出来
  //是哪个数字就转换成ascll码,没想出来怎么做
  function itob(x) {
    //存储数字变化为字符串
    var num = 0
    //存储总字符
    var y = ''
    //判断是不是数字
    if (!isNaN(x) && Number.isInteger(x)) {
      while (x > 0) {
      var ge = x % 10
        switch (ge) {
          case 0:
            num = '0'  
            break;
          case 1: 
            num = '1' 
            break;
          case 2:
            num = '2'  
            break; 
          case 3: 
            num = '3' 
            break;
          case 4:
            num = '4'  
            break; 
          case 5:
            num = '5'  
            break; 
          case 6:
            num = '6'  
            break;   
          case 7:
            num = '7'  
            break;
          case 8:
            num = '8'  
            break;
          case 9:
            num = '9'  
            break;
        }
        y = num + y
        x = (x - ge) / 10
      }
      
       console.log(y);
    }else{
      console.log('输入整数');
    }
    
    }  
  // function itob(x) {
  //   var num = 0
  //   var y = ''
  //   while (x > 0) {
  //     var ge = x % 10
  //       switch (ge) {
  //         case 0:
  //           num = '0'  
  //           break;
  //         case 1: 
  //           num = '1' 
  //           break;
  //         case 2:
  //           num = '2'  
  //           break; 
  //         case 3: 
  //           num = '3' 
  //           break;
  //         case 4:
  //           num = '4'  
  //           break; 
  //         case 5:
  //           num = '5'  
  //           break; 
  //         case 6:
  //           num = '6'  
  //           break;   
  //         case 7:
  //           num = '7'  
  //           break;
  //         case 8:
  //           num = '8'  
  //           break;
  //         case 9:
  //           num = '9'  
  //           break;
  //         default:
  //           console.log('不是数字');
  //           break;
  //       }
  //       y = num + y
  //       x = (x - ge) / 10
  //     }
  //     
  //      console.log(y);  
  //   }
</script>

<script type="" id="???">


</script>

<script type="ok" id="lcf&lcm">
  //最大公约数 
  function lcf(x,y) {
    //~除数不能为0，但是y >= 0会返回NaN错误~
    //y > 1 就避免了在y > 0最后一次循环的时候,z = 0的情况
    while (y > 1) {
          var z = x % y
          x = y
          y = z 
    }
   return y    
  }
  
  function lcm(x,y) {
    //~除数不能为0，但是y >= 0会返回NaN错误~
    //y > 1 就避免了在y > 0最后一次循环的时候,z = 0的情况
    let m = x * y
    while (y > 1) {
          var z = x % y
          x = y
          y = z 
    }
    //这是一个公式
   return m / y    
  }
  
  lcf(1997,615)
  lcm(1997,615)
</script>

<script type="ok" id="countBs">
function countBs(x) {
  let bNum = 0
  for (let i = 0; i < x.length; i++) {
    //字符串B
   if (x[i] == 'B') {
      bNum++
   }  
  }
  return bNum
}
</script>
<script type="ok" id="counts">
  function counts(x,y) {
    let Num = 0
    //存储需要统计的字符串
    
  for (let i = 0; i < x.length; i++) {
    //字符串B
   if (x[i] == y) {
      Num++
   }  
  }
  return Num
}

</script>
<script type="ok" id="HappyNumber">
//可以不转换成字符串做出来，用ge一个一个取出来不就行了？
/*function isHappy(n) {
  //转成字符串，i < m.length
  let m = '' + n
  //存储算完后的字符串
  let z = 0
  //存储平方和
   y = 0

   if (n < 10) {
    return false
   }

while (true) {
    for (let i = 0; i < m.length; i++) {
    let x = parseInt(m[i])
    y = y + x * x
    z = y + ''
  }
  m = z
  y = 0

  if (m == 1) {
      return true
      break
    }
}

    if (m == 1) {
      console.log('true');
    }
  } */

  //调试了半天，查资料才发现快乐书为false时一定会包含数字"4"
 /*
  debugger
function isHappy(n) {
  if (n < 10) {
    return false
   }else if(n == 1){
    return true
   }

  let m = 0
  //000
  let x = 0
  while (true) {
      while (n > 0) {
        let ge = n % 10 
            m = ge ** 2 +  m
            n = (n - ge) / 10
            if (m == 1) {
              return true
            }else if (n < 0 && m != 1) {
              return false
            }
      }

      n = m  
      m = x 
  }

}
isHappy(20)*/

function isHappy(n) {
  let sum = 0
  while (n > 0) {
    let ge = n % 10 
     sum = ge ** 2 + sum
     n = (n - ge) / 10

  }
  if (sum == 1) {
    return true
  }
  if (sum == 4) {
    return false
  }
  //传递的是sum
  return isHappy(sum)
}

</script>
<script type="ok" id=" power of two">
  debugger 位运算
  //这个方式会造成过大的次幂运算
  /*function isPowerOfTwo(n) {
    //存储2的n次幂
    let x = 0

    for (let i = 0; i <=Infinity; i++) {
      x = 2 ** i
      if (n == x) {
        return true
      }   
    }
    return false
  }*/
 //传统方式，倒着来
  function isPowerOfTwo(n) {
    //存储2的n次幂
    if (n <= 0) {
      return false
    }
  // n % 2 == 0 , 为true时表明是2的次幂
    while (n % 2 == 0) {
      n = n / 2
    }

    return n == 1

    //下面这一堆还不如直接返回return n == 1
  /*
  //这个if要放在外面，2 ** 0 =1
    if (n == 1) {
        return true
      }
      //再然后不对的就返回
      return false*/
  }
</script>

<script type="ok" id="Base 7">
  
   function isPowerOfTwo(num) {
    //%7公式混淆，声明混淆
   //满足一些负数,先转换成正数
       // 处理0的特殊情况
       if (num === 0) {
        return "0";
    }
   let m = num
    if (num < 0) {
      m = -1 * num
    }else{
      m = num
    } 
  //转换为7进制
  let result = ''
    while (m > 0) {
      result = (m % 7) + result//拼的顺序
      //这里num不需要再次声明了
      m = Math.floor(m / 7)
    }
 

    if (num > 0) {
      return result
    }else if (num < 0) {
      return '-' + result
    }else{
      return 0
    }
    }
  
  isPowerOfTwo(0)

</script>
//, target
<script type="" id="Two Sum">
  
  function twoSumfunction(nums,target) {
    
    //方法1
      //记录原数组中每个数所在的位置（索引）
      var record = []
      for (let i = 0; i < nums.length; i++) {
        var current = nums[i]
        //对于target,我们需要多少才能加出target
        var need = target - current
        //如果我们知道need在哪里，就完事了
        if (record[need] > -1) {
          return[i,record[need]]
        }
        //记录当前数字在哪里
        record[current] = i
      }

    //方法2
    /*let x = 0
    let y = 0

   //nums.length - 1 ， 最后一个数不用比
    for (let i = 0; i < nums.length - 1; i++) {
      x = nums [i]  
      //取[i]的下一个
      for (let o = i + 1; o < nums.length; o++) {
        y = nums [o]  
        if (x+y == target) {
        //gan,又没看清题目的返回值
        return [i,o]
       }
      }
    }
  }
  twoSumfunction([2,7,11,15],9)*/

  }
</script>

<script type="ok" id="Perfect Number">
  function checkPerfectNumber(n) {
    //存储正因子的和
    let totalN = 0
    for (let i = 1; i < n; i++) {
      if (n % i == 0) {
        totalN = totalN + i
      }
    }
    if (totalN == n) {
      return true
    }
    return false
  }
</script>

<script type="" id="Max Consecutive Ones">
  debugger
  /*方法1function findMaxConsecutiveOnes(n) {  
   //记录1出现的次数
    let oneCount = 0
    //记录1连续出现的数组
    let oneContinue = []
    for (let i = 0; i < n.length; i++) {
      if (n[i] == 1) {
        oneCount++
      }else if (n[i] == 0) {
        oneCount = 0
      }
      oneContinue.push(oneCount)
    }
    //找最大值，要加...
    return Math.max(...oneContinue)*/

  /*方法2
    //记录1出现的次数
    let oneCount = 0
    //记录1出现的最大次数
    let max = 0
    for (let i = 0; i < n.length; i++) {
      if (n[i] == 1) {
        oneCount++
        if (max < oneCount) {
          max = oneCount
        }  
      }else{
        oneCount = 0
      }
      
    }
    return max
  }*/

  //方法3


</script>

<script type="other" id="Fizz Buzz">
  function fizzBuzz(x) {
    //存放值的数组
    let list = []
    for (let i = 1; i <= x; i++) {
      if (i % 3 == 0 && i % 15 == 0) {
        list.push('FizzBuzz')
      }else if (i % 3 == 0) {
        list.push('Fizz')
      }else if (i % 5 == 0) {
        list.push('Buzz')
      }else{
        list.push('' + i)
      }
    }
    return list
  }

</script>

<script type="ok" id="ugly-number">
  // function isUgly-number(n) {
  //   if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0  || n == 1) {
  //     return true
  //   }
  //   return false
  // }
  function isUgly(n) {
  if (n <= 0) {
    return false;
  }
  
  while (n % 2 === 0) {
    n /= 2;
  }
  
  while (n % 3 === 0) {
    n /= 3;
  }
  
  while (n % 5 === 0) {
    n /= 5;
  }
  
  return n === 1;
}
</script>

<script type="other/low" id="Power of Three">
  function isPowerOfThree(n) {
    if (n <= 0) {
      return false
    }
    while (n % 3 == 0 /*&& n !=0 在这里的话就不会返回false*/) {
      n = n / 3
      //在这里return true会while为true就返回
    }

    return n == 1
  }
</script>

<script type="ok" id="addDigits">
  debugger
  function addDigits(n) {
    let sum = 0
    while (n > 0) {
      let ge = n % 10
      sum += ge
      n = (n - ge) / 10
    }
    if (sum < 10) {
      return sum
    }
      //n = sum //可以不要这句话，sum  = n,只是赋值而已
      return addDigits(sum)
    }
    addDigits(14)
  
</script>

<script type="low" id="singleNumber">
function singleNumber(n) {
  for (let i = 0; i < n.length; i++) {
    let isSingleNumber = true
    for (let o = 0; o < n.length; o++) {
      if (i != o && n[i] == n[o]) {
        isSingleNumber = false
        break
      }      
    }
    //?需要放在第一个for内部用以比较第二个for对比的n[i]时候是否需要输出,不过当有两个独立的数字时return会直接第一个结束?
    if (isSingleNumber) {
      return n[i]
    }
}
}

</script>

<script type="other,最后一个解法的思路以及标准解法" id="countBits">
  、/*function countBits(n) {
    //存储转换为2进制的数
    let x = ''
    for (let i = 0; i < n.length; i++) {
      
        while (x > 0) {
          let y = n[i] % 2 
          //这种先准换成二进制数然后再统计是否有1,多此一举，不如直接统计n[i] % 2 为1的个数
          x = y + x
          y = n[i] / 2  
        }
      console.log(x);      
      }
      
    }*/
   debugger
   function countBits(n) {
    //存储有几个1的数组
    let one = []

    for (let i = 0; i <= n; i++) {      
          //count计数=1,并且每次完成一个数的统计后重新计数
          let count = 0
          //避免修改 i 影响循环
          let x = i
      while (x > 0) {
        //相当于短除法的余数
        let y = x % 2 
        //统计为1
        if (y == 1) {
          count++ 
        } 
        x = Math.floor(x / 2) 
      }
      one.push(count)
   }
      return one
   }
  countBits(2)
</script>

<script type="" id="Count Primes">
function isPrimes(n) {
  //0,1不是质数
  if (n <= 1) {
    return false
  }
  for (let i = 2; i <= Math.sqrt(n) ; i++) {
      if (n % i == 0) {
        return false
      } 
    }
       return true
  } 

function countPrimes(n) {
  let count = 0
//从i到n的数字
  for (let i = 0; i <= n ; i++) {
    if (isPrimes(i)) {
      count++
    }
  }
  return count
}  

//埃斯托利筛选法

</script>

<script type="ok,other" id="isPalindrome">
  function isPalindrome(x) {
    //先转成字符串再遍历
    let o = '' + x
    //小于0的不是回文数
    if (o < 0) {
      return false
    }

    //提取出来，再一个一个比较。二分法,这里为奇数个时候会直接跳出最中间的那个数，返回true
    for (let i = 0; i < o.length / 2; i++) {
      //对应比较的数(变量名字有点不清晰)
      let y = o.length - i - 1
      if (o[i] !== o[y]) {
        return false
      }
     
    }
    return true
  }

 
</script>

<script type="" id="minMoves">
  //每次操作都会增加两个元素的值，那么让其中一个值减1，就相当于另外两个值加1
function minMoves(n) {
  //先找出最小值
  let min = Math.min(...n)
  //计算要多久
  let count = 0
  for (let i = 0; i < n.length; i++) {
    let x = n[i] - min
    count += x
  }
  return count
}
</script>

<script type="" id="moveZeroes">//似乎可以用二分法

    //有写不出来的预感
    /*for (let i = 0; i < n.length; i++) {
      if (n[i] == 0) {
        //取得为0的下标
      let x = n.indexOf(n[i])
        //删除0
      x.splice(0, 1)
      }  
    }*/
    
    function moveZeroes(n) {
      //记录等于0有多少个
    let count = 0
    //splice会改变原数组，导致正向遍历的时候length改变，所以反向遍历
    for (let i = n.length - 1 ; i >= 0; i--) {
        if (n[i] == 0) {
          count++
          n.splice(i,1)
        }
      }  
      for (let i = 0; i < count; i++) {
        n.push(0)  
      } 
      return n
  }

function moveZeroes(nums) {
  var i = 0//下一个非0的位置
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] !== 0) {
      nums[i] = nums[j]
      i++
    }
  }
  //用最后得到的i，让其后面都是0
      while (i < nums.length) {
      //i后面就是0
      nums[i++] = 0
    }
}
 
</script>

<script type="ok二分法" id="searchInsert">
  function searchInsert(n,target) {
    for (let i = 0; i < n.length; i++) {
     if (n[i] == target) {
      return i
     }else if(n[i] != target){
      for (let i = 0; i < n.length; i++) {
        if (target < n[i]) {
          n.splice(i,0,target)
          return n.indexOf(target)
          //数组下标应该是0~n.length - 1
        }else if (target > n[n.length - 1]) {
          n.push(target)
          return n.indexOf(target)
        }
      }
     }
    }
  }

</script>
<script type="ok" id="findDuplicates">
  //找出相同的数字似乎不能用twoSum的那种方法
  //时间复杂度太高了
  function findDuplicates(n) {
    //统计数组
    let x = []
    for (let i = 0; i < n.length; i++) {
      for (let o = i + 1; o < n.length; o++) {
       if (i != o && n[i] == n[o]) {
        x.push(n[i])
       }
      }    
    }
    return x
  }
  findDuplicates([4,3,2,7,8,2,3,1])
</script>

<script type="time7-21" id="climbStairs">
  
  //Time Limit Exceeded
  function climbStairs(n) {
    let count = 0
    //从地板开始走
    function tab(start = 0) {
      if (start > n){
        return
      }else if (start == n) {
       
        //位置放错了
        count++
        return
      }
      tab(start + 1)
      tab(start + 2)   
    }
      tab()
      return count
  }
</script>
<script type="ok" id="addStrings">
   function addStrings(num1, num2) {
    //接收一个一个加起来的和
    var sum = 0
    //存储字符串
    var result = ''
    //存储十进制的进‘1’
    var one = 0

    //从后面向前面加
    var x = num1.length - 1
    var y = num2.length - 1

    //循环加
    while(x >= 0 || y >= 0 || one != 0){
      //one != 0,是为了处理x,y < 10 && x+y == 10的情况下，x,y在一次循环后'下标'就变成负数结束循环的情况。
      //需要处理12，2。是1+2的情况。x,y < 0 undefined,那么小于0的时候直接让这一位等于0
      var digit1 = x >= 0 ? Number(num1[x]) : 0
      var digit2 = y >= 0 ? Number(num2[y]) : 0

      //one,10进‘1’
      sum = sum + digit1 + digit2 + one

      //进‘1’,一定要放在这里，放在result后面会变成小数
      //Math.floor取整数保证，只取到1
      one = Math.floor(sum / 10)

      //清空这两位数>=10 ，前的1。    
      //sum必须在前，不然位置不对
      result =  sum % 10 + result 
      
      //清空sum
      sum = 0
      x--
      y--
    }
    return result   
  }
  /*//Number会损失精度
   function toNumber(num1, num2) {
    return Number(num1) + Number(num2)
  }
  function addStrings(num1,num2) {
    //函数调用问题
    let x = toNumber(num1, num2)
    //存储数字变化为字符串
    var num = 0
    //存储总字符
    var y = ''
    //判断是不是数字
    if (!isNaN(x)) {
      do {
      var ge = x % 10
        switch (ge) {
          case 0:
            num = '0'  
            break;
          case 1: 
            num = '1' 
            break;
          case 2:
            num = '2'  
            break; 
          case 3: 
            num = '3' 
            break;
          case 4:
            num = '4'  
            break; 
          case 5:
            num = '5'  
            break; 
          case 6:
            num = '6'  
            break;   
          case 7:
            num = '7'  
            break;
          case 8:
            num = '8'  
            break;
          case 9:
            num = '9'  
            break;
        }
        y = num + y
        x = (x - ge) / 10
      }while (x > 0)   
      return y
      }
    }*/

 

</script>

<script type="NO" id="distributeCandies">
  function distributeCandies(candyType) {
    //统计能吃多少糖 种类做map
    let sum = candyType.length / 2
  }
</script>

<script type="ok,timeOut,7-22,20:15" id="mergeSortedArray">
function mergeSortedArray(nums1,m,nums2,n) {

  //先把nums2的加入nums1
  for (let i = 0; i < nums2.length; i++) {
    nums1.push(nums2[i])
  
  //sort是JS数组的自带方法
  nums1.sort(
    function(a,b){
      return a - b//升序 、b - a降序
      }
    )  
  }
 

  //删除0,从前面删除会改变顺序，从后面开始删除
  for (let p = nums1.length - 1; p >= 0 ; p--) {
    if (nums1[p] == 0) {
      nums1.splice(p,1) 
    }
      //nums1.length = m+n的长度
  if (nums1.length <= m + n) {
    break
  }
  }
  return nums1
}
mergeSortedArray([-1,0,0,3,3,3,0,0,0],6,[1,2,2],3)
</script>


<script type="2NO" id="Pow(x, n)">
  function myPow(x,n) {
    if (n < 0) {
      return 1 / myPow(x,-n)
    }
    if (n%2 == 0) {
      var t = myPow(x,n/2) //n >>>1,无符号位移
      return t * t
    }else{
      var t = myPow(x,n/2) //n >>>1
      return t * t * x
    }
  }
</script>


<script type="maybe,正反" id="excel">
  function convertToTitle(columnNumber) {
    let z = ''
    while (columnNumber > 0) {

      //先获得字母的unicode
      //columnNumber - 1 是保障不错位
      let x = (columnNumber - 1) % 26 



      //'A'.charCodeAt(),获得首字母A的unicode,然后再String.fromCharCode转换成字符串
      
      z = String.fromCharCode(x  + 'A'.charCodeAt(0)) + z 

      //取整以实现只取26以上的数，
      //(columnNumber - 1)跳出循环和保障正常进位,不减去的话Math.floor会剩余自动向上取整从而多出‘1’
      columnNumber = Math.floor((columnNumber - 1)  / 26)

    }

    return z
  }

  function convertToTitle(columnNumber) {

      //先获得字母的unicode
      let x = columnNumber % 26 
      //'A'.charCodeAt(),获得首字母A的unicode,然后再String.fromCharCode转换成字符串
      //x - 1 是因为保障不错位
      let y = String.fromCharCode(x - 1 + 'A'.charCodeAt())

      console.log(y);
  }
  convertToTitle(2)
</script>

<script type="ok" id="Sqrt(x)">
  //传统方法
  var mySqrt = function(x) {
    let a = 0
    for(var i = 0;i<=x;i++){
        if(i*i<=x){
            a = i
        }else{
          //用于跳出循环，还真想不到。。。。
            i=x+1
        }
    }
    return a
};
  //二分法,x一直除以2 = y，寻找y *y = x
  function mySqrt(x) {
    //0，1
    if (x == 0 || x == 1) {
      return x
    }
    let left = 0
    let right = x
    while (left<=right) {
      //根据二分法原理要middleXX > x or middleXX < x middle +/- 1 ，但又不能取到中间值所以Math.floor
      let middle = Math.floor((left + right) / 2)
      let middleXX = middle * middle
       if (middleXX == x) {
        return middle
       }
       //更新边界值,middleXX > x,边界向左移动找到更小的值
       else if (middleXX > x) {
        right = middle - 1
       } 
       //更新边界值,middleXX < x,边界向右移动找到更大的值
       else if (middleXX < x) {
        left = middle + 1
       } 
    }
    //就是在向最小的边界靠近 。想不清debugger一遍
    return right
  }
</script>

<script type="ok" id="singleNonDuplicate">
  function singleNonDuplicate(nums) {
    for (let i = 0; i < nums.length - 1; i += 2 ) {
      //奇数偶数对比
    
        if (nums[i] != nums[i + 1]) {
          return nums[i]
        }  
       
    }
    //前面都相同那就返回最后一个奇数，因为只有奇数不同
    return nums[nums.length - 1]
  }

  //二分法 [1,1,2]，因为加入了循环反而慢了
  function singleNonDuplicate(nums) {
    if (nums.length == 1) {
      return nums[0]
    }
    let left = 0
    let right = nums.length
    //找的不能是同一个数字，下标不能相等
    while (left<right) {
      let middle = Math.floor((left + right) / 2)
      //这里要等于，否则无法对应下标
      for (let i = 0; i <= middle - 1; i += 2) {
        if (nums[i] != nums[i + 1]) {
          return nums[i]
        }else{
          //向右找
          left = middle + 1
        }   
      }
  }
  return right
}

//二分法 + 题目理解
function singleNonDuplicate(nums) {
    if (nums.length == 1) {
      return nums[0]
    }

    let left = 0
    let right = nums.length



    while (left<right) {
      let middle = Math.floor((left + right) / 2)
      //确保从偶数开始找起
      if (middle % 2 == 1) {
        middle--
    }

    if (nums[middle] == nums[middle + 1]) {
      //向右移
      left = middle + 2
    }else{
      //不相等右闭区间就不变
      right = middle
    }
    }
    //变化的是奇数
    return num[left]
  }
</script>


<script type="OK" id="TowSum 2">
  function twoSumfunction(nums,target) {
      //记录原数组中每个数所在的位置（索引）
      var record = []
      for (let i = 0; i < nums.length; i++) {
        var current = nums[i]
        //对于target,我们需要多少才能加出target
        var need = target - current
        //如果我们知道need在哪里，就完事了
        if (record[need] > -1) {
          return[record[need] + 1,i + 1]
        }
        //记录当前数字在哪里。先记录i,再记录record
        record[current] = i
      }
    }
    twoSumfunction([2,7,11,15],9)
</script>


<script type="ok" id="递归1">
  function x(n) {
    if (n == 1) {
      return 0
    } else {//这里不用分开另一个函数
      return 2 * x(n - 1) + n * n
    }
  }

</script>

<script type="ok" id="walkTab">
  function walkTab(step) {
    function tab(start = 1 , how = '始') {
      if (start > step){
        return
      }else if (start == step) {
        console.log(how);
        return
      }
      tab(start + 1 , how + '+ 1 步')
      tab(start + 2 , how + '+ 2 步')
    }
      tab()
  }
</script>

<script type="maybe" id="walkUp">//x,y
  //step是沿着边缘走的最短距离
  function walkDirection(step) {
    //统计有多少种走法，因为最后start > step的时候会return。所以初始值为1
    let count = 1
    function direction(start = 1 , how = '始') {
      if (start > step) {
        return
      }else if (start == step) {
        console.log(how);
        return
      }
      
      direction(start + 1 , how + ' + 向上走1步 ')
      direction(start + 1 , how + ' + 向右走1步 ')
      count++
    }
    direction()
    console.log('总共'+count+'种走法');
  }

</script>

<script type="ok" id="concat">
  function concat(){
  //返回的新数组
  var result = []
  //arguments,不知道输入多少个就用这个
    for (let i = 0; i < arguments.length; i++) {
      //获得函数里面的每一个值
      var arg = arguments[i];
      //如果是数组那就遍历数字然后相加
      if (Array.array(arg)) {
        for (let j = 0; j < arg.length; j++) {
          result.push(arg[p])  
        }
      }else{
        result.push(arg)
      }
    }
    return result
}
</script>

<script type="" id="valid-anagram">
  
 
  
function iaAnagram(s,t) {
  
  if (s.length != t.length) {
    return false
  }

  //字符串展开排序再合并
  let x = [...s].sort().join('')
  let y = [...t].sort().join('')

  return x == y


}
Anagram("anagram","nagaram")
</script>


<script type="" id="bulls-and-cows">
function getHint(secret, guess) {
  
  //数字对位置对记为A
  let countA = 0
//先检测A的条件,字符串可以遍历
  for (let i = 0; i < secret.length; i++) {
    //if
    if (secret[i] == guess [i]) {
      countA ++
    }
  }

//这是在记录有多少个数字对但是位置不对
  //存储secret每个数字有多少个
  let map1 = {}
  for (let num of secret) {
    //如果secret的数字在map1中，就记录
    if (num in map1) {
      map1[num]++
    }else{
    //第一次寻找没有就赋值1，相当于记录了第一次
      map1[num] = 1
    } 
  }
  
  //存储guess每个数字有多少个
  let map2 = {}
  for (let num of guess) {
    //如果guess的数字在map1中，就记录
    if (num in map2) {
      map2[num]++
    }else{
    //第一次寻找没有就赋值1，相当于记录了第一次
      map2[num] = 1
    } 
  }  

  //获得key值以对比元素值
  let keys1 = Object.keys(map1)
  let keys2 = Object.keys(map2)

  //计数符合B，数字对但是位置不对
  let countB = 0
  for (let key of keys1) {
    
    //原数组secret中出现的次数map1[key] ，猜测guess数组中出现的次数map2[key]
    //不只是相等map1[key]的数字出现次数大于map2[key]出现次数也要countB++ 
    //key in map2 为 true , 为false说明猜错了   
    if (key in map2) {
      if (map1[key] >= map2[key]) {
      //guess数组中出现的次数map2[key]，因为是要取guess多少为*B。
      //key值一样那必定是相同的，就看数字出现了多少次
      countB += map2[key]
    }
         
    else{
      //原数组secret中出现的次数map1[key]，因为是要取secret多少为*B。
      //guess，map2[key]就算相同map1[key]且出现的次数多也不需要计算，相当于是猜错了
      countB += map1[key]
    }
  }
  }
   //数字对但是位置不对（B）- 猜对了多少个数字（A）减去,去除位置已经对了的数字（A）
   countB = countB - countA
  return countA + 'A' + countB + 'B'
}
</script>


<script type="ok,other" id="word-pattern">
function wordPattern(pattern,s) {
  //先对比二者的长度
  //把s用split(" ")按空格分割为可以比较长度的数组
  let word = s.split(" ")
  //分割字符串pattern
  pattern = [...pattern]
  //长度对比
  if (pattern.length != word.length) {
    return false
  }

  //建立用于对比的对象
  //对象的接收
  //word为key值
  let wordPattern = Object.create(null)//创造没有原型的对象就没有默认值了，避免冲突
  //pattern为key值
  let patternWord = Object.create(null)//创造没有原型的对象就没有默认值了，避免冲突
  //用循环写入key值
  for (let i = 0; i < pattern.length; i++) {
    //互为对方的key和value
    let w = word[i]
    let p = pattern[i]
    //第一次获得循环的时候wordPattern[w]是空值undefined
    if (wordPattern[w] != undefined) {
    //如果wordPattern的key为[w]的值！= p(pattern下标表示的值)  
    //因为pattern，是有相同规律排序的"abab"，这种。在后面的循环一定会再次出现wordPattern[a],就可以进行对比是不是一样了
      if (wordPattern[w] != p) {
        return false
      }
      }
      //第一次获得key为[w]的值的时候wordPattern[w]是空值undefined，就先赋值p(pattern下标表示的值)
      else{
        wordPattern[w] = p
      }

      //反过来同理
    if (patternWord[p] != undefined) {
      if (patternWord[p] != w) {
        return false
      }
    }else{
        patternWord[p] = w
      }
  }
  return true
}
</script>

<script type="ok,other" id="isomorphic-strings">
function isIsomorphic(s, t) {
  //先分割字符串，字符串可以遍历，不需要分割
  // s = [...s]
  // t = [...t]

  //声明对象
  let objectS = Object.create(null)//创造没有原型的对象就没有默认值了，避免冲突
  let objectT = Object.create(null)//创造没有原型的对象就没有默认值了，避免冲突


  for (let i = 0; i < s.length; i++) {
  //每个都写上s[i]、t[i]容易引起混乱,虽然会慢一点（增加了时间复杂度）
  let x = s[i]
  let y = t[i]    
  //互相作为键值对
    if (objectS[x] != undefined) {
      if (objectS[x] != y) {
        return false
      }  
    }else{
      objectS[x] = y
    }
    
    if (objectT[y] != undefined) {
      if (objectT[y] != x) {
        return false
      } 
    }else{
      //s[i]
      objectT[y] = x
    }
  }
  return true
}
</script>

<script type="ok" id="longest-substring-without-repeating-characters">
function lengthOfLongestSubstring(s) {
  //需要把元素放到对象里面去
  let Object = {}
  //滑动窗口
  let start  = 0;

  let maxLen = 0
  //end指针
  for (let end = 0; end < s.length; end++) {
    let char = s[end] //当前end指针在哪里，以及是哪一个字符
    //更新start的位置
    //
    //Object[char] >= start 就说明重复了，需要向前移动位置
    if (char in Object && Object[char] >= start) {
      //Object[char] + 1 ，向前移动一个位置
      start = Object[char] + 1
    }
    //没有的话就加入元素统计字数
   
      //更新end的位置
      Object[char] = end
    
        // 计算当前最长子串长度
        maxLen = Math.max(maxLen, end - start + 1);
  }
  return maxLen
} 

</script>
<script type="ok" id="longest-substring-without-repeating-characters-two">
function lengthOfLongestSubstring(s) {
  let obj = {}
  let start = 0
  let maxLen = 0

  //遍历每一个字符
  for (let end = 0; end < s.length; end++) {
    //初始化
    obj[s[end]]=(obj[s[end]] || 0) + 1
    /*if (obj[s[end]]) {//非空
      obj[s[end]]++
    }else{
      obj[s[end]] = 1
    }*/
    //左边界end调整
    /*调整左边界，减少计数
        obj[s[start]]--：obj[a]--
        字符串："abcabcbb"
        窗口：[b, c, a]
        字典 obj：{a: 1, b: 1, c: 1}
        start：1
        end：3
        maxLen：3*/
    while (obj[s[end]] > 1) {
      //删除最左边的值
      obj[s[start]]-- //跟obj[s[end]] == obj[s[start]]没有关系，s='baabcbb'
      //向右移动
      start++
    }
    //5~1 , 5-1 = 4 , length = 4+1 =5
  maxLen = Math.max(maxLen,end - start + 1)
    
  }
  return maxLen
}
</script>

<script type="ok" id="first-unique-character-in-a-string">
function firstUniqChar(s) {
  //存储的元素
  let x = {}
  //遍历s,作为x的key
    for (let key1 of s) {
      if (key1 in x ) {
        x[key1]++
    }else{
        x[key1] = 1
    }  
    }

  //拿到key值  
  let y = Object.keys(x)
  //解决forEach无法return的问题
  let result = -1
  //拿到value == 1
  for (const key2 of y) {
    if (x[key2] == 1) {
              [...s].forEach((it,index) => {
          if (it == key2) {
            result = index
          }
        });
        if (result != -1) {
          break
        }
    }
  }  
  return result
}
</script>

<script type="" id="sort-an-array-sortArray">
    function swap(array,i,j) {
    var t = array[i]
    array[i] = array[j]
    array[j] = t
  }
  //冒泡排序
  //思路
  /**/
  function bubbleSort(nums) {
    //end相当于比较的终点
    for (let end = nums.length - 1; end > 0; end--) {
      //优化
      let swapped = false
      //一个一个与i后面一个数字比较
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] > nums[i+1] ) {
          //交换他们的位置
          swap(nums,i,i+1)
          swapped = true     
    }   
     } 
     if(swapped = false){
      break
     }
    }
    return nums
  }
  //选择排序
  function selectSort(nums) {
    //遍历未排序部分找出最小的,最后一个最大不用找
    for (let i = 0; i < nums.length - 1; i++) {
      //先选出最小的数字，假设第一个最小。取下标，取数字的话会改变。
      let minIdex = i
      //i后面的一个数j
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[minIdex] > nums[j]) {
          //把最小值放到最前面，然后剩下的排序
          minIdex = j
          //这里swap(nums,minIdex,j)，虽然结果一样，但是就变成了插入排序
        }  
      }
      swap(nums,i,minIdex)
    }
    return nums
  }
  //插入排序
  function insertSort(nums) {
    //第一个元素已经被排序默认最大,最后一个最大不用比较了
    for (let i = 0; i < nums.length - 1; i++) {
      //将第一个元素与后面的逐个比较
      for (let j = i+1; j < nums.length; j++) {//j不能是1，要跟着i动。because:nums.length - 1
      //交换   
      if (nums[i] > nums[j]) {
        swap(nums,i,j)
      }    
      }  
    }
    return nums
  }
</script>

<script type="ok" id="deepEqual">
  // 判断a,b是否相同,如果是对象,看内容是否相同
  // 即深对比
//以下是浅对比
function deepEqual(Object1,Object2) {

// 判断a,b是否相同,如果是对象,看内容是否相同。并且不能为空
  //是不是对象,typeof返回的是'object'字符串
  if (typeof Object1 === 'object' && typeof Object2 === 'object' && Object1 !== null && Object2 !== null) {
      //先获取key值的长度看是否一样
      //Object.keys()，返回的是由key值组成的数组
      let keys1 = Object.keys(Object1)
      let keys2 = Object.keys(Object2)

      //若长度不一样那就没必要比较
      if (keys1.length != keys2.length) {
        return false
      }

      //取出key1里面的值作为let key
      for (let key of keys1) {
        /*key2在不在.includes(key),key里面 
        !keys2.includes(key) 的作用是检查 keys2 数组中是否 不 包含 key 元素。如果 key 不在 keys2 中，则表达式返回 true；如果 key 在 keys2 中，则表达式返回 false。
        || deepEqual递归对比Object1,Object2下每个元素的内容是否相同的 */
        if (!keys2.includes(key) || !deepEqual(Object1[key],Object2[key])) {
          return false
        }  
      }
      return true
      }else{
        return Object1 === Object2    
      }
}
</script>

<script type="ok" id="reverseArrayInPlace">
  function reverseArrayInPlace(array) {
  var stop = Math.trunc(array.length / 2)
for (let i = 0; i < stop; i++) {
  var j = array.lrngth - i -1
  var temp = array[i]
  array[i] = array[j]
  array[j] = temp
}
return array
  }
</script>

<script type="" id="sum,range">
function range(start,end,step = 1) {
  //输入一个值，但希望生成从1到这个值
  if (arguments.length == 1) {
    end = start
    start = 1
  }
  let result = []
  //为了保证倒序的时候正确使用问号表达式
  for (let i = start; step > 0 ? i <= end : i >= end ; i+=step) {
    result.push(i)
  }
  return result
}

function sum(params) {
  let result = 0
  //不需要下标只需要取值用of比较好。params是数组
  for (i of params) {
    result += i
  }
  return result
}
</script>
</head>

<body>
</body>