
浮点数的表示(IEEE754标准)
  JS语言里的数值其实都是有IEEE754标准存储的浮点数
    但是js中的数值在参与位运算时会保留这个数的整数部分的低32位来参与运算
  IEEE754标准中能够存储的最大精确整数为:
    2**53 - 1 大约等于  9后面15个零(书本第一章)
    即当底数部分的所有位都用来表示整数时,52 + 1位
  IEEE754中有正负零,即零有两种表示方式
  实际上NaN以及正负无穷大在IEEE754中也有相应的表示方式
    指数全1底数全0为正无穷
    符号位为1则为负无穷
    NaN也有相应的表示(略)
    虽然IEEE754中有定义这些特殊的数,但不是每种语言中都有这几个特殊数
  为什么不在底数放前指数放后?
    为什么指数部分不使用补码来存(即整数的表示)?
      为了能够从前往后按位扫描就能够区分两个浮点数的大小
        具体来说,即除符号位以外,谁先遇到1谁就更大
          可以更快的知道哪个数更大.
    为什么浮点数比大小这么重要?
      因为IEEE754不能精确表示任何一个十进制浮点数
        所以我们很少对比两个浮点数的相等性
        而是比较大小,或者是比较距离(a-b<0.0001)
      计算结果理论上相同的两个浮点数极有可能因为计算路径的不同而不一样
  为什么不存底数部分中的那个整数?
    因为那个数总是1,总是不变,就不用存了
  实际上的有效数字的数量为53位
    如果全用来存整数,则最大可以表示2**53-1,所以在这个之内的整数及其运算都是精确的
    但如果有小数部分,则整数部分就不能表示那么多了
    这意味着如果整数部分越多,则小数部分越少,那么精度就越小
      (精度说的总是小数部分,因为整数部分总是精确的(在2**53-1范围内时))
    也就是说数越大,小数部分精度就越小
    但如果全部用来表示小数,则精度可以很高
    总的来说,数越小,小数部分越精确,数越大,小数部分越不精确
  存储为的二进制状态转换为十进制时实际可以精确到小数点后53位甚至更多,但为什么只显示十几位?
    因为50几位的二进制表示的状态也就跟十几位十进制表示的状态数量差不多
    所以双精度浮点数在写成十进制时,最多也就只有十六七位的有效数字




字符串的表示
  ascii:是为每个字母,数字等英文符号指派了一个编号,一共255个符号.
  保存ascii范围内的字符,好说,直接就是这些数的二进制,一个字符占一个字节
  unicode:是为全球每个国家的每种语言的每个字符指派了一个编号
  如何保存unicode中的每个字符?
  不能直接把每个字符的编号直接转成二进制存储吗?
    理论上能,但是unicode由于编号范围太大,所以字符的编号跨度也大,a是97,"某个字符"可能是375434
    很明显的是除英文字符以外的其它的字符一个字节是不够存的
    所以要想存unicode内的所有字符,每个字符占一个字节肯定是不够的
      那每个字符占两个字节够不够?
        两个字节可以表示65536种不同的状态,显然也是小于全世界所有语言所有符号的数量的.
      那三个字节行不行?
        三节字节可以表示1670w种不同的状态,目前来说是铁定够了的.
    所以能不能每个字符就占固定的三个字节来存储呢?
      能.
    但是这样做有没有什么问题?
      有问题
      当我存的都是编号较小的字符时,空间就有浪费
      因为每个字符的编号根本就占不到三个字节.
    所以我们期望每个字符占用的字节数量是不确定的,字符号编号越大,字占的空间越多,字符编号越小,占用的空间就越小
      即**变长编码**
    如何表示当前这个字占用几个字节?
      用第一节字节来表示
        理论上可行,但有点浪费
          很明显,多数的字就只占用1 到 3节字节,你用一个字节仅用来表示1到3这三个数,有点浪费.
      用前三个bit来表示字节数量
        可以
        但是,这样一来,这种编码方式就跟ascii不兼容了
          (即ascii范围的字符与ascii编码不一样)
        而我们希望我们的编码算法能够兼容ascii,即前256或者至少前128个符号是跟ascii一模一样的
        如果数据中丢了一字节或多字节,数据会乱掉
      用每个字节的第一个bit表示后续有无字节
    实际中是怎么表示的?
      用第一个字节的**前导1的个数(前导1的后面有一个0)**来表示这个字占多少个字节
        多字节符号后续的字节以10开头
      单字节字符以0开头(兼容ascii 128以内的字符)
      变长变码(连编码这个字符占几个字节的部分都是变长的)
      可以在丢失字节时,不打乱后续的字符(因为每个字符的后续字节必须10开头,不是10开头则说明是下一个字符了)
        (即,可以通过这个后续字节10开头来识别字节的丢失)
    以上就是UTF8编码
    需要注意UTF8与UNICODE不一样
    unicode是为字符指派编号
    utf8是对编号进行二进制的编码
    类似的还有utf16编码,每个单位是16bit,首个编码单元的前导1的个数表示这个字的编码单元数量
      (这里的编码单元对于utf8来就是1字节,对于utf16是两字节)
