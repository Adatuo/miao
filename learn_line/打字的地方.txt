

2024/09/20
promise如果失败，并且没有一个处理失败函数，则它的报错会出现在控制台
onunhandledrejection事件

Promise/A+标准
https://promisesaplus.com/#notes


阅读这两篇文章：
https://web.dev/articles/promises?hl=zh-cn


https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html
中文：
https://blog.csdn.net/jokerjiaojiao/article/details/103116241


20:14 9/22谢然


  p.then().then().then().then().then()
注意这两种不一样
  p.then()
  p.then()
  p.then()
  p.then()
  p.then()





  p.then().then().then().then().then()
  这两者是等价的
  p = p.then(f)
  p = p.then(f)
  p = p.then(f)
  p = p.then(f)
  p = p.then(f)





var p = new Promise(...)

  for (let url of urls) {
    p = p.then(() => url)
  }
等价于
  urls.reduce(() => {
    return p.then(() => url)
  }, new Promise(...))



factory function
工厂函数：专门创建某个东西的函数
document.createElement('span')


promise构造时的executor函数是立即执行的，在构造函数内被已经被调用了，不会异步执行
class Promise {
  constructor(executor) {
    try {
      executor(resolve, reject)
    } catch(e) {
  }
}

作业：实现Promise.xxx上的所有函数
all,race,allSettled,any,try,withResolvers


20:45 9/23谢然




// all,race,allSettled,any,try,withResolvers


Promise.try = function(f) {
  return new Promise((resolve, reject) => {
    try {
      var result = f()
      resolve(result)
    } catch(e) {
      reject(e)
    }
  })
}

function any(promises) {
  return new Promise((resolve, reject) => {
    var errors = []
    var len = promises.length
    var count = 0

    if (len == 0) {
      reject(new AggregateError([]))
    } else {
      for (let i = 0; i < len; i++) {
        let promise = promises[i]
        Promise.resolve(promise).then(value => {
          resolve(value)
        }, reason => {
          errors[i] = reason
          count++
          if (count == len) {
            reject(  new AggregateError(errors)  )
          }
        })
      }
    }
  })
}

function withResolvers() {
  var resolve, reject
  var promise = new Promise((re, rj) => {
    resolve = re
    reject = rj
  })
  return {
    promise,
    resolve,
    reject
  }
}

function allSettled(promises) {
  var {promise, resolve} = Promise.withResolvers()
  var result = []
  var len = promises.length
  var count = 0

  if (len == 0) {
    resolve(result)
  } else {
    for (let i = 0; i < len; i++) {
      let promise = promises[i]
      Promise.resolve(promise).then(value => {
        result[i] = {
          status: 'fulfilled',
          value,
        }
        count++
        if (count == len) {
          resolve(result)
        }
      }, reason => {
        result[i] = {
          status: 'rejected',
          reason,
        }
        count++
        if (count == len) {
          resolve(result)
        }
      })
    }
  }

  return promise
}

function race(promises) {
  return new Promise((resolve, reject) => {
    for (var promise of promises) {
      Promise.resolve(promise).then(resolve, reject)
    }
  })
}

function all(promises) {
  return new Promise((resolve, reject) => {
    var result = []
    var len = promises.length
    var count = 0 // 记录成功的promise的数量
    if (promises.length == 0) {
      resolve(result)
    } else {
      for (let i = 0; i < promises.length; i++) {
        let promise = promises[i]
        Promise.resolve(promise).then(val => {
          result[i] = val
          count++
          if (count === len) {
            resolve(result)
          }
        }, reason => {
          reject(reason)
        })
      }
    }
  })
}

// 静态方法
Promise.resolve = function resolve(val) {
  return new Promise(resolve => {
    resolve(val)
  })
}



promise.finally(f)：
promise无论成功与失败f都会执行
finally只接一个参数
f不接参数
finally返回一个新的promise2
如果f返回promise3，则promise2会等待promise，但不会取它的结果，而是取promise的结果
即一个promise的结果会穿透它的finally调用到finally返回的promise对象上

Promise.prototype.catch = function(f) {
  return this.then(null, f)
}

Promise.prototype.finally = function(f) {
  // return new Promise()
  return this.then((value) => {
    return Promise.resolve(f()).then(() => value)
  }, (reason) => {
    return Promise.resolve(f()).then(() => {throw reason})
  }) // p3
}




polyfill：
当前浏览器不自带，但新版本的浏览器或语言支持某函数/class
自行实现一个跟未来版本自带的一样的函数/方法/class就称为polyfill
典型的polyfill：
  在IE6中实现Map，Set，Promise
  在IE8中实现Array.prototype.map/filter/reduce或者 Array.of/from/isArray

shim：
垫片
就是无法在旧旧版环境中完全模拟新版本环境的行为，但可以解决一定的问题，称shim
示例：
 在旧浏览器中实现console.log
  这并不能真正的实现这个功能，因为旧版浏览器都没有控制台，但是实现一个这样的函数可以让代码在调用console.log时不报错



9/25谢然

function get(url) {
  return new Promise(resolve => {
    var xhr = new XMLHttpRequest()
    xhr.open('get', url)
    xhr.onload = () => {
      resolve(xhr.responseText)
    }
    xhr.send()
  })
}

function delay(time) {
  return new Promise(resolve => {
    setTimeout(resolve, time)
  })
}

function getValue(value, time) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(value)
    }, time)
  })
}


function co(generatorFunction) {
  return new Promise((resolve, reject) => {
    var generator = generatorFunction()
    try {
      var generated = generator.next()
      step()
    } catch(e) {
      reject(e)
    }

    
    function step() {
      if (generated.done === false) {
        Promise.resolve(generated.value).then(val => {
          try {
            generated = generator.next(val)
            step()
          } catch(e) {
            reject(e)
          }
        }, reason => {
          try {
            generated = generator.throw(reason)
            step()
          } catch(e) {
            reject(e)
          }
        })
      } else {
        resolve(generated.value)
      }
    }
  })
}

function run(generatorFunction) {
  return new Promise((resolve, reject) => {
    var generator = generatorFunction()
    var generated = generator.next()

    step()
    
    function step() {
      if (generated.done === false) {
        Promise.resolve(generated.value).then(val => {
          generated = generator.next(val)
          step()
        }, reason => {
          generated = generator.throw(reason)
          step()
        })
      } else {
        resolve(generated.value)
      }
    }
  })
}


function run(generatorFunction) {
  return new Promise((resolve, reject) => {
    var generator = generatorFunction()
    var generated = generator.next()

    step()
    
    function step() {
      if (generated.done === false) {
        Promise.resolve(generated.value).then(val => {
          generated = generator.next(val)
          step()
        })
      } else {
        resolve(generated.value)
      }
    }
  })
}

function run(generatorFunction) {
  var generator = generatorFunction()
  var generated = generator.next()

  step()
  
  function step() {
    if (generated.done === false) {
      Promise.resolve(generated.value).then(val => {
        generated = generator.next(val)
        step()
      })
    }
  }
}



async function * baz() {
  await delay(1000)
  yield 2
  await delay(1000)
  yield 3
  await delay(1000)
  yield 4
}
var gen = baz()
// 异步生成器函数的next总是返回promise，返回的promise将会resolve出{value,done}这样的对象
// 因为异步生成器并不一定能立马运行到下一条yield语句，
// 因为可能在遇到下一条yield语句之前遇到await语句，那么就必须等这个await恢复
// for await (var x of asyncGeneratorFunction() ) {}
// for await 语句可以用遍历/迭代异步生成器生成的值，这个语句自然也会运行与异步生成器函数一样久的时间
// 同时它只能出现在async函数里


作业：

1 阅读这篇文章：
https://bluepnume.medium.com/even-with-async-await-you-probably-still-need-promises-9b259854c161

2 使用异步函数实现图片一张一张下载的那个作业。








20:23 9/26谢然

regenerator runtime






20:13 9/27谢然

语义化版本号 sematic version
修复bug，提升性能，但不改变也不新增现有接口，只更新最后一位版本
新增功能，更新第二位版本号
破坏现有功能，更新主版本号




es module 语法：
export 关键字：具名导出，导出的东西必须有名字
在任何可以导出的东西前面加export不改变这条语句原本的任何含义

export default 默认导出：导出一个值，其后跟表达式

每个模块文件自身就有一个作用域
其内通过var/let/const创建的变量处于模块作用域内

当要导出一个已经存在的变量为具名导出时：
export { jQuery }

通过import语法创建的变量相当于const创建的，所以不赋值，不重复创建或导入相同名字的东西

导入具名导出
import {chunk, compact} from './lodash.js'
导入默认导出
import confetti from './confetti.js'
import lodash from './lodash.js'

导入某个模块的全部导出：
import * as XXX from './xxx.js'
这种语法下，XXX是一个“模块对象”
XXX.named 为相应具名导出
XXX.default 为它的默认导出


import和export语句只能出现在模块文件的最顶层，即不能出现在代码块（{}）里面，如if，for，while，函数等里面

模块的路径那里虽然是个字符串，但只能是静态字符串，不能有运算

动态导入：
import还可以做为一个函数，接收一个模块路径，动态导入相应的模块
动态导入由于是一个普通的函数调用，所以它可以放在代码的任何位置，如if，for，或函数里
var lodashMod  = await import('https://esm.sh/lodash')
上面的语法得到的对象跟下面语法得到的lodashMod对象是相同的
import * as lodashMod from 'https://esm.sh/lodash'





21:17 9/28谢然

eval能直接读到调用它的位置周围的变量，只要给定的代码中使用到了周围的变量，它就能读到，所以eval不受“词法作用域”的限制
普通函数是不能直接读到调用位置周围的变量的。（把调用位置周围的变量传给函数不算）函数只能直接读到定义位置周围的变量

eval直接使用会在使用的位置运行给定的代码
但如果把eval赋给任何其它变量后，通过这个变量调用它，则它会在全局作用域执行给定的代码
即将eval赋给其它变量后，它丢失了打破词法作用域限制的能力。




setTimeout(  'console.log(1)',    2000)



20:16 9/29谢然


目前的同步require不能接受，有两个原因：
一个原因是所有的模块都是串行加载的，需要的时间太久
二是加载过程中（由于是同步加载）页面还是无响应（阻塞）的


作业：将loadFileAndAllDeps再使用promise风格和async await风格实现一遍，并观察加载时的瀑布图，与回调风格的做对比


使用先异步加载所有依赖再从入口开始执行的办法依然存在性能问题：
最长依赖链决定了整个加载所需的时间
（并且使用es module同样存在这个问题）


所以我们现在不会直接在浏览器中使用未经打包的模块加载方式，那样太耗时了
而是会通过类似webpack等工具把所有的代码打包到单个文件中（也可以配置成打包到多个文件中）
事实上，es module也会这么处理，并且es module自身由于不能打包，所以会被webpack先转成common js的模块书写方式再进行打包


关于循环依赖：
  模块不能替换module.exports
  模块不能同步使用导入模块的提供的方法等，因为同步拿到的可能是空的导出对象，等模块都加载完后这个对象才有内容





20:42 9/30谢然

试试email的“查看原文”功能。一般会打开一个页面，里面只有纯文本，但是也有一些格式和标记




作业：https://todomvc.com/
实现 todo list
必须要实现刷新还在的功能。


21:47 10/3谢然

以数据为中心实现的todo list虽然解决了数据与ui的一致性问题
但是它还是可以进一步优化的：
1 我们必须手动调用renderPage()
  目标：数据变了自动调用
2 由于使用的是事件代理，所以很多不同元素的操作都放在同一个函数的不同片段
  而且还是根据类名或某种选择定位到相应元素
  目标：每个按钮或元素的操作单独放在一个函数里
  目标：直接把函数放到元素上而不是在事件代理函数里判断事件来源于哪个元素
3 模板语法（js模板字符串，要是以前只能是字符串拼接，那更难受）不够友好
  目标：更友好的模板写法
4 模板结构并不是就地出现在页面里的
  目标：如果能够直接出现在页面里可能更方便
5 不管数据有多少微小的变化，我们都是全量更新app元素中的innerHTML的
  当页面太大时，必然会导致性能浪费，最终卡顿
  当给innerHTML赋值时，浏览器是会解析给写的html字符串为dom的，这个是有隐含耗时的
  目标：只更新需要更新的部分，而不是全量更新innerHTML
  （但是现在是字符串，想通过innerHTML的方式只更新需要更新的部分不太好做）
  （这些字符串其实表示的是html结构，也即树状结构）（所以我们想要的可能是对两个颗树比较差异）


Vue.js框架实现了以上所有目标！


vue模板语法：
  {{expr}}可以在标签之间插值
  :attr="expr"属性插值
  v-for="(item,idx) of/in array"
  @eventname="func()" 绑定事件
  v-if="expr" 元素的存在（于dom中）与否
  v-show="expr" 元素的显隐（display:none)
  v-model="expr" 双向绑定：变量的值会影响到元素的状态，用户与元素的交互状态又会回到变量上

20:36 10/4谢然

声名式的对立面叫“命令式”


通过innerHTML给dom插入的script/style标签在现代浏览器中是不会执行的，因为它有安全隐患

所有v-开头的属性的属性值都是表达式，除v-for以外。



<span v-bind="obj"></span>：
obj的所有property将成为span的所有attribute



vue3使用proxy来实现响应式的原因：
proxy比getter/setter更强大，可以提供对对象的全方位监控；而g、setter只能监控已经存在的属性的读写。

proxy性能更好：g/setter需要一开始就把所有的（包括深层次）属性都改成g、setter，而proxy不需要，只需要在一开始对最外层对象做一次proxy包裹



各种异步调用函数的方法：
setTimeout(f)
requestAnimationFrame(f)
promise.then(f)
setImmediate(f)
process.nextTick(f)
queueMicrotask(f)








20:32 10/5谢然


简单的依赖收集原理：
var obj = {
  get a() {
    deps.push('a')
    return 1
  },
  get b() {
    deps.push('b')
    return 2
  },
  get c() {
    deps.push('c')
    return 3
  }
}

var deps = []

function f() {
  return obj.a + obj.c
}
function g() {
  return obj.a + obj.b
}

deps = []
f()
console.log(deps)

deps = []
g()
console.log(deps)







vue2中v-if 与v-for用在同一个元素是，for优先级更高
vue3是反过来的


vue2中对数组下标直接赋值是不会被响应式系统感知到的，所以不会因此更新dom。因为vue2没有把数组的每个下标改成getter/setter，所以监控不到
但vue3中同样的行为会被感知到，因为3中用的是proxy，可以监控数组下标的赋值
面试常问；







22:00 10/7谢然

但凡考虑到“封装”，都有两个角度：
一是使用者/消费者角度
二是实现者/生产者角度
在学习阶段，学习者通常同时处于两个视角。
有时会混淆二者。



组件的属性英文一般叫props
区别于attributes和property
html标签的属性叫attribute
标签的dom对象的属性叫property




作业：
用vue组件化实现轮播图
要求要有指示器，要有ui，加分：要有动画
接参：slides, autoplay
autoplay参数表示是否会自动播放，如果不传则不自动播放
传了则传一个数，按这个数（毫秒）为时间间隔自动播放





20:04 10/8谢然


谁的模板用谁的数据。



mounted与beforeUnmount其实就对应于组件的资源分配与释放
类似于程序在启动后建立网络连接，在关闭前（或使用完连接后）关闭网络连接
在一个class构造时分配存储空间，在这个class需要被销毁时，释放之前分配的存储空间
c++语言里有“构造函数”和“析构函数”
构造函数：分配空间，给空间内的值填入初始值，动态分配空间



对比两个vnode结点的大致算法：
从根结点开始对比。
如果结点的标签名相同，则修改旧的标签的属性到新的标签属性（如果属性以及事件也都相同，则啥也不用改）
  然后递归（可能是按顺序）对比它们的子元素
如果结点的标签名称不同，则删掉旧的标签及其内容，在同样的位置构建新的标签结构。也无须递归对比后代了。
遇到组件时：



作业：实现tabs组件
data() {
  return {
    items: [{
    key: '1',
    label: 'Tab 1',
    children: 'Content of Tab Pane 1',
  },
  {
    key: '2',
    label: 'Tab 2',
    children: 'Content of Tab Pane 2',
  },
  {
    key: '3',
    label: 'Tab 3',
    children: 'Content of Tab Pane 3',
  },]
  }
}
模板里：
<tabs default-active-key="1" :items="items"/>




21:07 10/9谢然


作业：为轮播图和tabs组件加上合适的事件以让使用者能够知道组件内发生了什么。


作业：实现个key/value编辑器组件

_______:______ -
_______:______ -
_______:______ -
+

<map-input v-model="someMap"></map-input>

作业2： 实现一个日期选择器，要求其双向绑定的值的类型是Date

<date-input v-model="birthday" ></date-input>

birthday: new Date()





22:55 10/11谢然

作业：
仅使用setup实现一个todo list应用
使用setup的方式实现前面作业中的几个组件：轮播图和tabs，日期选择器






21:09 10/12谢然


正常情况下是通过模板编译出render函数

setup也可以直接返回一个render函数

render函数都是用来返回一个vnode结点的函数






20:21 10/13谢然



能够感知自己在哪个函数里调用的示例代码（注意是在哪个函数里，不是哪个组件实例里）
原理就是onMounted感知到的是自己在最后一个被run调用的函数里面

function onMounted() {
  console.log('我正在被谁调用：', currentFunction.name)
}

function foo() {
  onMounted()
}

function bar() {
  onMounted()
  run(foo)
}
function baz() {
  // run(baa)
  baa()
}
function baa() {
  onMounted()
}

var currentFunction = null

function run(f, ...args) {
  var previousCurrentFunction = currentFunction
  currentFunction = f
  try {
    var result = f(...args)
    return result
  } finally {
    currentFunction = previousCurrentFunction
  }
}




异步组件处于加载中状态时，suspense组件会显示其fallback
加载完成会显示实际组件
当异步加载中组件被suspense包裹时，从suspense外面看，这个suspense组件不牌加载中状态，从外面看它就是一个普通的组件。






极简的监控数据并更新页面并批量更新的原理代码：


var scheduledUpdate = false

function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      return target[key]
    },
    set(target, key, val) {
      target[key] = val
      if (scheduledUpdate == false) {
        scheduledUpdate = true
        Promise.resolve().then(() => {
          update()
        })
      }
    }
  })
}

function update() {
  console.log('更新页面')
  scheduledUpdate = false
}



vue2与vue3的另一个重要区别是
1 模板编译器的编译方式不同
vue3编译结果有相当大的性能优化：具体体现在模板中静态的内容在render函数中不会每次创建，而是创建一次后续都一直使用

2 vue3中可能没有再使用虚拟dom对比来更新页面中需要更新的部分
  而是根据模板推导出哪个数据变了应该去更改dom中的哪个部分
  它可以分析出数据与dom中的哪个部分有关联，可以精确到文本结点以及dom结点的属性，当数据发生变化时它直接就去更新dom中对应的位置，没有vnode生成，也没有vnode的差异对比，性能飙升

3 vue中能让dom结构发生变化的只有v-if/else和v-for，没有使用v-if/v-for的部分，dom结构肯定不发生变化，只会是文字内容或属性发生变化
 
4 编译出来render函数返回的结果中包含编译器对模板的理解，以更好更快的实现dom的更新



作业：用拆分组件的方式实现todo list

20:38 10/14谢然


相邻组件上层通过给下层传props来实现向下层传递信息，
下层组件通过事件向上层组件传递信息，事件对象中就包含了具体的信息

如果组件不是相邻层次的，则通过provide给下层组件传递信息
上层组件并不能直接侦听下层组件的事件，但上层组件可以为下层provide一个函数，下层在合适的时机调用这个函数并传入参数，即可把信息从下层以传到上层。





一般来说，组件是封闭的个体，只应该接收数据并消费数据，但不应该修改数据。但是当应用变的复杂，复杂到它需要拆分成多个、多层的组件时，此时上下层组件都服务于整个应用的业务逻辑，这个时候，上下层组件就会共用数据了，可能都会用到数据，也可能都会修改相应的数据。




组件的props只在开发阶段会判断类型，在应用上线后是不会判断的，以节省时间。
不判断会不会出错呢？如果开发阶段都ok，那么上线后应该也是ok的。


开发环境：
测试环境：
预发布环境：
生产环境：




vue.esm-browser.js
vue.runtime.esm-browser.js
runtime版本是仅包含运行时版本，不包含编译器
与运行时对应的叫编译时即上面一个版本，它也包含（模板）编译器



HMR：模块热更新：
可以做到在特定情况下，修改了代码后，页面不刷新就可以看到新的效果




作业：
根据这里的教程在自己的电脑上创建vue项目
https://cn.vuejs.org/guide/quick-start.html

windows特别注意：
winpty  npm.cmd  create vue@latest

cd 项目文件夹名称
npm install 
npm run dev 




20:31 10/15谢然



mapState的极简实现：https://pinia.vuejs.org/zh/core-concepts/getters.html

mapState(useCounterStore, {
  myOwnName: 'doubleCount',
  // 你也可以写一个函数来获得对 store 的访问权
  double: (store) => store.doubleCount,
})


function mapState(useStore, obj) {
  var store = useStore()

  var ret = {}

  for (let key in obj) {
    let val = obj[key]
    if (typeof val == 'string') {
      ret[key] = () => {
        return store[val]
      }
    } else if (typeof val == 'function') {
      ret[key] = () => {
        return val(store)
      }
    }
  }

  return ret
}


作业：https://cn.vuejs.org/guide/essentials/application.html
用组合式api风格再读一遍文档中的教程

作业：阅读Vue英文文档。



作业：创建项目在项目中用pinia实现拆分组件的todo list





22:00 10/17谢然

vite的工作原理：
将我们写的代码转换到能够被浏览器直接执行和加载的es module的程度。开发阶段不打包


作业：使用vue-router画一个类似微信的界面切换出来



22:10 10/18谢然


不同的历史记录模式的区别：
优选web hash history mode：
所有浏览器都支持
无论#号后面是什么，刷新时都只请求#号前面的地址，所以有缓存
无需后端额外做配置

web history mode:
支持history.pushState的浏览器支持，不支持时会自动退化到web hash history
好处是地址栏好看，但这个好处卵用没用，用户会去看地址栏吗？99%不会，会又如何？
坏处是没缓存：假设入口地址是http://localhost:5000/
在页面内交互了一段时间后，地址变成了http://localhost:5000/foo/bar
此时刷新页面，请求的是这个地址，而不是之前的入口地址

需要后端服务器做额外的配置才可以：
即以入口地址开头的任意地址都要返回与入口地址相同的内容（注意不是跳转到入口地址）。

http://localhost:5000/
http://localhost:5000/woief/woeijrw/woeir
http://localhost:5000/#/woief/woeijrw/woeir

乱打一个地址对于一个常规网站来说会怎样？
会404
但现在我们希望它返回与入口地址一样的内容
所以要对服务器进行特殊的配置





20:04 10/19谢然



js中值有类型，但变量没有类型
所以变量可以在任何时候指向任何一个类型的值
这样的语言叫动态类型。
类似js，python都是动态类型的语言


还有不少的语言是静态类型，即变量也有类型，一旦确定了变量的类型，这个变量就只能指向这个类型的值了。
这种叫静态类型。
类似c，c++，java都是静态类型的语言


语言的另一种分类方式：强类型与弱类型
强类型：不支持自动类型转换，python，java
弱类型：支持自动类型转换，c，js，




静态类型能够（让工具，如编辑器、编译器）更早的帮你发现低级错误。在对代码进行静态分析的时候就能发现一些错误。
静态分析：即不运行代码，只对代码的源代码进行分析。


js语言并不会在代码运行之前检查代码的类型使用，只会检查语法错误。即只要代码的语法没有错误（只要每一行代码能以某种方式运行成功），代码就会开始运行。


一般来说，做为库的提供者，我们需要写类型声明
但做为库的使用者，我们不太会在自己的代码中写太多不必要的类型声明


在静态类型的语言里，一个数组中的所有元素必须有着相同的类型。
也就是数组也是有类型的：由特定类型的值组成的数组。



Contextual typing for function这个特性必须要求函数就地书写在相应的位置（一般来说是参数的位置）


ts常见面试题：
type跟interface有什么区别
type是运算
interface是声明

type可以声明联合类型
interface不能

interface不能给原始类型起别名

interfacr名字总会出现在报错里，而type alias不一定

类型别名不能参与声名合并，而interface可以

interface只能声明对象类型，typealias也可以声明原始类型的别名


interfaces extends 对编译器更加的性能友好




// 这句话不是在做类型转换，ts从来不会给值做类型转换，只是在告诉ts这个值的类型，让ts更好的提示我们
const myCanvas1 = document.getElementById("main_canvas") as HTMLCanvasElement

// 同样的写法在c语言里是类型转换
const myCanvas2 = <HTMLCanvasElement>document.getElementById("main_canvas")

// 这句话在c语言里就是把getInt函数的返回值转换为float类型
float x = <float>getInt()


TypeScript only allows type assertions which convert to a more specific or less specific version of a type.


类型其实是值的集合：
boolean是由true和false组合的集合
c语言的int是由-2147483648到2147483647之间所有的数组成的集合
string是由任何字符串组成的“无限集合”


作业：阅读ts文档英文版：
https://www.typescriptlang.org/docs/handbook/2/everyday-types.html


21:27 10/20谢然


Narrowing： 类型收窄，类型窄化


freshness        21:9 10/20谢然

never类型的用法  21:25 10/20谢然



函数有返回值的类型

但函数自身也有类型：函数的类型标注了 函数的参数类型与返回值类型

因为js支持高阶函数，所以有时我们会有一系列函数，以相同的方式接参，并返回相同类型的值



it’s not legal to do anything with an unknown value
https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown



21:09 10/21谢然


function，interface，type以及class都支持泛型


作业：假装用ts实现一个MyPromise类，标注相关函数及参数以及返回值的类型；
不需要实现代码中的逻辑，只需要把类型标注出来即可





20:56 10/22谢然


// infer的意思是，如果传入T类型能让inferU位置填入某种类型后让条件判断成立
// 那么请把应该填入inferU位置的类型赋值给U类型，然后该类型可以问号右边使用
type Flatten2<T> = T extends Array<infer U> ? U : T;





21:37 10/22谢然

// 对于函数的A extends B来说
// 满足A类型约束的函数一定可以以B类型的约束来调用，这种时候extends才成立
// 对于参数来说，A的参数类型可以比B的参数类型丰富，对于返回值来说，B的返回值类型可以比A的返回值类型丰富

type GetReturnType<Type> = Type extends (a:number,b:string) => boolean | number
  ? number
  : never;

type X6 = GetReturnType<(a:number | symbol,b:string) => boolean>



https://github.com/type-challenges/type-challenges



20:24 10/23谢然


Promise类型声明作业解答：


type PromiseResolver<T> = (value: T) => void

type PromiseRejector = (reason: any) => void

type PromiseExecutor<T> = (resolve: PromiseResolver<T>, reject: PromiseRejector) => void



// T是MyPromise内包着的东西的类型
class MyPromise<T> {
  constructor(executor: PromiseExecutor<T>) {
    const resolve: PromiseResolver<T> = (value) => {

    }
    /* function resolve(value: T): void {

    } */
    function reject(reason: any): void {

    }
    // const reject: PromiseRejector = (reason) => {

    // }
    executor(resolve, reject)
  }
  then<U, V>(onResolved: (value: T) => U, onRejected: (reason: any) => V): MyPromise<U | V> {
    return new MyPromise((resolve, reject) => {

    })
  }
}

var p = new MyPromise<number>((resolve, reject) => {
  resolve(2)
})

var q = p.then(v => {
  return 'woeij'
}, e => {
  return true
})









作业：用React的class组件实现一个轮播图组件





21:45 10/24谢然


jsx的标签之间的插值如果是boolean,null,undefined，'',则会当成空，不显示任何内容

react中双击事件是onDoubleClick不是ondblclick

阅读react官方英文（建议英文版）
https://react.dev/learn

作业：用React的class组件实现TodoApp










20:29 10/25谢然======================================

sourcemap是什么，运行的是编译后/压缩后等的代码，调试的时候还是调试的源代码是怎么回事？
编译结果代码的最后一行 //# sourceMappingURL=xxxxxx.js.map 是什么意思？
它里面记录了什么信息？
  记录了源代码的文件名及文件内容。所以这个文件在上线后一定一定是不能泄露的，别一起把这个文件也上线了





class组件的setState是同步的还是异步的？什么时候同步什么时候异步？
在16版本的时候，有时同步有时异步
  同步时会立即合并state并且立即更新dom
  什么时候同步？当setState所在调用栈中没有一系列的react函数时。在ajax回调/或异步函数的回中调用时是同步。在事件中调用是异步的。


在最新的18版本中，始终是异步的。
  通过queueMicrotask/postMessage触发的（事件中，直接由我们调用）
  
17版本我不记得了/不知道。因为17版本被react官方当做一个过渡版本，所以很多公司根本不用的

setState做了什么？


react生命周期示意图
https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/



20:39 10/26谢然=======================

jsx和vue3都会忽略html代码行首行尾的空白
vue2不会






react的useXxxx函数在同一个组件实例内，不能改变调用顺序
在同一个组件的多次渲染中，也不能改变调用次数


react面试必问题目：为什么hook不能改变调用顺序



错误的归因：
为什么react hooks不能改变调用顺序？
因为使用了链表嘛，当然不能换顺序，因为链表只能顺序访问
正确的原因：并不是因为链表，而是因为api的形式，useState函数只能隐含的知道自己的调用顺序，所以只能返回对应顺序的状态，而与该状态的用处（名字）无关。



作业：用函数组件实现轮播图

20:04 10/27谢然============================

传统中（包括各种语言中）我们写函数一般只关心函数的参数和返回值（有时还会关心抛出）
不会关心函数在哪调用
更不会限制函数只能在哪调用
同一个函数的多次调用之间，往往是没有关系的
（除非少数情况下这个函数会使用并/或改变全局变量）

react的hooks函数：
只能在函数组件内调用
由于hook函数只能通过感知自己隐含的调用顺序来返回组件不同的状态
同一个函数在一个组件内的多次调用，会返回不同的值



在react18中，函数组件的setState也是异步的


js的label语法，（标识符后面跟一个冒号）:可以理解为对某一行代码标记位置（或者说起名字）
有的语言有一个goto语句，可以直接让代码跳转到某个label对应的行去执行

js中的唯一用法：在内层循环break外层循环
function foo() {
  a:
  for(;;) {
    b:
    for(;;) {
      break a;
    }
  }
}




20:05 10/28谢然===============================

函数组件并没有生命周期。不过它有类似的功能


c/c++语言里：
int a = 8
f(   a    )  // 传值
f(   &a   )  // 传引用,传地址


面试如果问到ref你除了要答出它用来指向元素以外
现在也用来模拟其它语言传引用的所有场景
或者说所有需要不同位置的代码共享数据时的场景
（一个地方改了，另一个地方能读到这个改动甚至能感应到（响应式））


react中：
字符串ref的用法现在不推荐了！
 （为什么？因为react代码内部在实现这种用法时太过复杂，远比对象ref和函数ref要复杂的多的多）
并且函数组件不支持字符串ref。只支持函数ref和对象ref。
对象ref：创建一个ref对象传给jsx的ref属性，jsx实例化后会被该ref的current指向
函数ref：创建一个函数并传给jsx的ref属性，jsx实例化为元素或组件后该函数会被调用并传入元素或组件做为其唯一参数（函数ref的另一个问题是名字不好起，要为函数自身起个名字，又要为元素挂在哪个字段上想一个名字，而且这两个名字不能一样）

class组件可以接ref，最终该ref指向class组件的class实例
函数组件不能接ref，因为函数组件没有实例（react会为函数组件创建所谓的FiberNode，但它是react内部实现我们拿了也没什么用）
同时函数组件内部不能使用字符串ref指向其它元素或组件






class组件除了state上可以放数据以外
this上也可以随意放数据（但注意不要覆盖别的属性）
而且直接挂在this上的属性修改时自然不会触发组件的更新（因为没有通过setState修改，再说了，setState也只能修改this.state属性）


函数组件有没有什么地方能放数据并且在修改的时候不触发组件的更新？
全局变量（外部变量）：可以，但意味着这个组件的所有实例会共享这些数据。
ref，一个组件实例的某一个名字的ref会在这个组件的生命周期内始终指向同一个ref对象



作业：完成轮播图组件将hover由state挪到ref上并保持组件功能不变。
（因为hover的改变并不造成组件的ui更新，只造成组件内部的定时器状态发生变化，所以hover不需要放到state上，这样一来hover变化不会造成组件的ui更新）





20:02 10/30谢然=============
函数组件一个ref，就像class组件this上的一个字段一样
ref之于函数组件就是this之于class组件






react的hook函数为什么不能更换顺序或者放到if里？
因为hook函数是通过隐含的调用顺序来区分不同的hook调用的
函数组件的多次运行中，同一调用顺位的hook函数是对应的，会对应相同的状态或对比各自的依赖

vue中的hooks函数可以换顺序调用或者放到if里吗？

vue根本就不存在这个问题！
因为vue的setup函数在一个组件实例上，只运行一次！




var f = useCallback(function XXX(){},   [deps])
等价于
var f = useMemo(() => function XXX(){},   [deps])

function useCallback(f, deps) {
	return useMemo(() => f, deps)
}





postMessage,setTimeout触发的回调在重绘之后调用

而已经成功的promise触发的回调在重绘之前调用，queueMicrotask也一样



expose： 10-11 22：53



https://19.react.dev/reference/react/forwardRef

In React 19, forwardRef is no longer necessary. Pass ref as a prop instead.




20:05 10/31谢然================================

react里的Context是react中用来解决数据的跨组件层级传递的机制。
生产者，一种用法：
<XxxxContext.Provider value={xxx}>

消费者，三种用法：
var value = useContext(XxxContext) // 注意没有.Consumer

<XxxxxContext.Consumer>
  {
    value => {return  jsx}
  }
</XxxxxContext.Consumer>

class组件中为class声明static contextType = XxxxContext
然后直接读取this.context即可


作业：实现
var forceUpdate = useForceUpdate()//调用forceUpdate就可以让组件强制更新了
useInterval
useToggle
useDebounce
useSet
useCounter




20:26 11/1谢然===============

任何时候写自定义hooks的时候
尽量返回的固定的函数，而不是每次运行时返回新的函数





基于旧的数据创建新的数据
旧数据中没变的部分，直接被新数据引用（即结构共享）
旧数据中变化的部分，创建新的数据
这种做法称做不可变数据：
即数据一旦创建出来，就不再修改了。
如果在整个应用中始终遵循这个些原则，
则react组件就可以根据接收到的“新的”props/state是否是新对象（其实就是用===判断）
而决定是否更新
但是原生js的语言下创建结构共享的不可变数据代码相当啰嗦



不可变数据在软件开发其它方面的影子：
git的提交，是不可变的
网站的url：很多网站的资源，一旦确定了url，此后这个url将始终指向这个资源的这个版本，不会变了
资源内容变了，会给个新的url





当你给immer.produce传入一个“变更函数”做为其首参时，其会返回一个函数用于接收想要执行那种变更的对象，并在接收到对象后为其执行那种变更，并返回应用变更后的新对象



作业：用immer实现todo，大幅简化代码




21:52 11/2谢然=================

组件 Component: 是那个函数或class

react元素:  React.createElement('div') <div></div>
组件实例:  new 出来的class实例。对于函数组件来说不存在实例
   new Button()





react里面的render props就大致对应于vue里的作用域插槽








20:04 11/3谢然====================================

高阶函数：一个函数接收或返回一个函数它就是高阶组件

高阶组件：一个函数接收并返回一个组件那么它就是高阶组件

在React里面，组件是 函数 或是 构造函数（class）

所以高阶组件它也是高阶函数

react里面的高阶组件函数一般以with开头后面跟上功能

以代表这个高阶组件为传入的组件带来了什么功能


一般来说高阶组件函数返回的组件会以某种方式使用传入的组件






react里有多种逻辑利用机制：
自定义hooks
以前还有mixin（vue现在都还有）
render props（接一返回jsx的函数并调用）
高阶组件
组件化开发本身也就是逻辑复用机制


一般来说写高阶组件都会把新组件接收到的props原样或大部分传给原组件




function debounce(f, time) {
  var id = 0
  function WrappedComp(...args) {
        clearTImeout(id)
	id = setTimeout(() => {
  	  f(...args)
        }, time)

  }
WrappedComp.displayName = f.displayName ?? f.name
}





组件的命令式与声明式api：

命令式：
<video />
var video = document.querySelector('video')
video.pause()
viode.play()


声明式：
this.setState({isPlaying: true/false})
<MyVideo playing={this.state.isPlaying} />


web性能优化
  网络传输的性能优化
  代码运行的性能优化
react性能优化

反问：你是想优化运行性能还是优化传输性能？




在react中使用高德地图的大致代码：

function AMap(props, ref) {
  var container = useRef()
  
  useEffect(() => {
    const map = new AMap.Map(container.current);
    ref.current = map
  }, [])

  return <div ref={container}></div>
}

var map = React.createRef()

<AMap ref={map}/>


作业：实现极简的虚拟化列表组件。




20:18 11/4谢然==================

useDeferredValue
useTransition


任何软件都有可能遇到两种反应慢的情况：
一种是运行时运算量太大，卡顿
  解决方案是减少一些运算量
一种是运行时网络太慢，loading
  只能让加载时的体验更好








react 19 中有一个叫use的hook函数
目前有两种用法：

function Test() {
  var p = useMemo(() => new Promise(), [xxx])

  var value    = use(p)

  if (xxx) {
    var color = use(ColorContext)
    var color = useContext(ColorContext)
  }

}

var MarkdownDocument = React.lazy(() => import('MarkdownDocument.js'))

<Suspense fallback={<div>'loading...'</div>}>
  <Test />
  <Suspense fallback={<div>'loading...'</div>}>
    <MarkdownDocument />
  </Suspense>
</Suspense>

这个use函数可以放进if里，可以像任何函数一个使用
原理是：它接收的对象，所以不根据自己的顺序来区分，而是根据自己的参数来区分需要返回的值
一定要传不是现场创建的对象，而是之前已经创建好的对象
接promise的时候不要传新创建的，而要传在组件外面创建的







有兴趣可以看看这个，尤其对fiber架构有兴趣：
https://pomb.us/build-your-own-react/




async f() {
  await xxxxx;
  await xxxxx;
  await f();
  await f();
  yyyy;
  yyy;
}



function f * () {
  yield xxxxx;
  yield xxxxx;
  yield f();
  yield f();
  yyyy;
  yyy;
}



作业：实现以下用法
<Tabs>
  <Tab name="Process">woiejfowiejf</Tab>
  <Tab name="Performance">woiejfowiejf</Tab>
  <Tab name="StartUp">woiejfowiejf</Tab>
  <Tab name="User">woiejfowiejf</Tab>
</Tabs>


上面的写法由于实现起来更复杂，所以现在更流行下面的写法(antd)


<Tabs xxxx={[ {}, {}, {}   ] }/>





<Tree>
  <Tree>
	<Tree></Tree>
	<Tree></Tree>
	<Tree></Tree>
  </Tree>
  <Tree></Tree>
  <Tree></Tree>
  <Tree></Tree>
</Tree>





20:09 11/5谢然=================================

组件的children不一定是个数组
可能是单个值，值可能是任何类型的，也可能是react元素，即jsx
可能是一个数组里面包含上述可能的类型
也可能是多层嵌套的嵌套的上述数组




react里面流行的（全局）状态管理库（vuex/pinia的类似物）
redux
recoil
jotai
zustand
mobx
immer
preact/signal
voltai


mobx与immer的作者是同一个人



作业：拆分组件并且某个全局状态管理库实现todo app
要求todo的状态由全局状态管理库来管理并最终被各层级组件使用。

可以通过以下链接创建在线vite项目
https://vitejs.cn/vite3-cn/guide/









22:47 11/6谢然======================


作业：用react router实现类似微信的界面间跳转功能




20:52 11/7谢然==============

小程序的页面栈有多深：6



搜索引擎如何决定你的网页排在第几位？
内容相关度
  这个在以往需要网页是由服务端渲染的
    但是随着动态页面的流行，搜索引擎已经可以抓取由框架在前端动态生成的页面了
页面的加载速度
https页面
反向链接数量（反向链接：类似于论文的被引用数量）
  即有越多的其它页面链接到当前页面，说明当前页面质量越高


toB to Business 给特定的人使用的（如售票系统，给公司员工用）
  一般来说tob的产品功能会更复杂，甚至往往需要培训上岗
  同时对细节和ui要求不多，能实现功能即可
  无需seo，所以无需ssr
  不用追求极速加载与运行速度
toC to Customer 任何一个自然人都可以使用（如taobao）
  toc的产品一般功能简单
  但是对ui和兼容性有比较高的要求
  需要seo来引流
  需要追求加载速度



静态站点生成 (Static-Site Generation，缩写为 SSG）
ssg适应的网站一般无需用户登陆，即所有用户看到的是一样的内容
这个时候就可针对每个url预先生成用户会看到的内容，就无需在前端运行组件挂载过程了（或可以省掉一部分时间）
vue文档网站即为ssg网站

csr client side rendering
ssr
ssg


nodejs：在js非浏览器的运行环境
nextjs是运行在nodejs之上的基于react的网站开发框架
  它集成了react的所有功能并增加了自己的功能如ssr以及ssg



服务端组件：
组件运行在服务端，返回的jsx会被react的后端转换为一个特定结构和格式的json
到了前端后，前端的react也能识别这个json所表达的jsx也即html结构并能知道它的结构中调用了哪些客户端组件。
从前端是看不到服务端组件的源代码和逻辑的（所以重要逻辑或商业机密型逻辑可以写在服务端组件中），客户端只能得到服务端组件的执行结果，也即是一个表达jsx的json。
服务端组件没有交互（所以没有effect之类的东西）
一般来说只是获取数据实现业务逻辑并返回结果（jsx（由json表达）表示的页面结构）




20:02 11/8谢然=========================


nodejs是什么，不是什么：

nodejs是一个js的运行环境，类似于浏览器，但js可以调用到的api集合不同
  在浏览器里，js能调用到的就是dom，bom，http请求等这些api
  在nodejs里，js程序可以调用到的是操作系统提供的各种api，如文件系统，完全的网络访问能力，启动系统上的其它程序，在系统中运行命令行脚本，在托盘增加图标并为图标增加菜单，对操作系统进行截图，连接数据库
基本上python，java能干的事情，nodejs都能干
  另外，运行在nodejs中的js程序，不受跨域限制，因为跨域限制是浏览器给到运行于其中的js的，浏览器以外一般都没有跨域限制。
但是对软进行各种权限限制现在也比较流行。nodejs未来也会加入相关功能，如只能让程序读写特定文件夹里的文件，网络功能如只能发送http请求（不能访问tcp/udp等功能）
deno
node
bun

除了node（包括deno，bun）还有没有其它的js运行环境呢？
mongodb数据库，操作这个数据的语言就是js
Auto.js，是一个安卓app，它可以让你通过自己写js脚本来控制自己的手机

var light = getSmartDevice('主卧的大灯')

light.on('23:30', () => {
  light.off()
})

曾经极氪汽车的发布会，他们说，以后会把汽车的api开放出来

微信小程序（包括各种xx小程序）


nodejs不是一个框架（如vue，react）不是个库（如lodash）

nodejs一般用来做什么：
高性能web服务器（即网站的后端）
命令行工具
爬虫
Electron（将浏览器与Nodejs集成到一个环境中）
  即可以利用浏览器的ui功能，又可以利用nodejs的网络，模块，文件等功能
  就可以实现很多应用了
  其实VSCode就是Electron实现的，据说飞书/网易云音乐/最新版QQ也是Electron开发的
    大部分日常应用都是由“画界面，读写文件，访问网络”这几个功能组合而成的
  一般用来开发客户端软件（qq，飞书）

前端构建、前端工程化：
  转义、编译（ts->js,es6->es5,less/sass->css)
  压缩、混淆（把易读的源代码转换成几乎不可读的，
  最主要的手段是通过改变形参的名字）
  打包，构建（（把从入口文件开始的所有使用到的文件
  打包成一个文件））
  如vite，webpack，esbuild


外设



但凡数据不是直接存在于内存里面，都可以称做是io数据
如从硬盘读写数据，从网络收发数据，等待用户的输入都算是IO




真正的线程跟浏览器里的worker的区别：
线程之间可以共享数据，可以同时访问某份数据（这也是线程的代码难以预测的原因）
而浏览器的worker之间是不能共享数据的。只能之间发消息，消息中带的数据是复制之后发过去的。从根源上杜绝了同时访问数据可能带来的难以控制的情况



异步需要通过多线程来实现。只是异步编程环境的系统将多线程的操作对我们的代码隐藏起来了，封装成了回调形式供我们使用。只是我们写的的所有代码在主线程这个单一线程运行。



zsh/bash/sh/fish  都是  shell，壳，就是跟操作系统沟通的命令行程序
可以在里面输入命令以控制操作系统启动或关闭程序（进程）

terminal 终端，一般来说终端可以是远程的
console 控制台，一般是当前机器的



在linux和max下，文件如果想当做程序执行，它需要有执行权限，没有执行权限的文件是不能执行的。
chmod +x add
chmod是修改文件权限的命令
mod： mode，模式，其中就包含权限
x表示eXecute
+表示增加这个权限
add是要操作的文件

chmod  777  add
一个文件的模式由多个方面组成：
文件类型，文件对于root用户的权限，对于所属用户的权限，对于所属用户组的权限
权限分为读、写、执行三种。每个权限由1比特来表示
rwxrwxrwx

软连接
硬连接
  硬连接的多个文件必须存在于同一个磁盘分区中


作业：实现一个factor2命令
分解质因数命令

作业：预习书本


20:23 11/9谢然===================

可以认为windows系统没有系统级顶层文件夹
linux和mac系统的/目录就是系统的顶层文件夹


npm install根据文件夹中是否有package.json文件来决定这个文件夹是否是项目的根目录


nodejs现在也直接支持import加载es modules
需要文件本身是模块文件，即扩展名为mjs





<script type="javascript"src="a.js"></script>
传统js文件，直接运行于全局作用域
不能使用import语句加载其它模块（不确定能不能用import函数，可以自己试一下）
<script type="module" src="a.js"></script>
模块文件，文件内是文件自身的作用域
可以使用import加载其它模块
可以使用顶层await


在node的最新版本里，require可以引入esmodule
反过来好像也能引，即import也能引入common js模块


require(x)，import的相对路径相对于那句路径所在文件
而其它的一些系统函数如fs.readFile(path)则是相对于工作目录




node中几乎所有回调风格的函数，回调函数都是接收两个参数，第一参数是可能的错误，第二参数是结果
fs.readFile('aaa.txt', (error, data) => {

})






registry=https://registry.npmmirror.com



pnpm为什么快
缓存已下载的包（通过将所有模块的所有文件通过文件的sha512 hash做为文件名来存储）
  那怎么还能节省空间呢？
    因为这个包的代码只会在存于系统中一次，即使它被多个项目所使用
它通过创建软硬连接来构建node_modules文件夹
  额外的好处是依赖更清晰




nodejs 的出现早于js中出现typed array 的时间

nodejs里的Buffer跟js标准中的typed array本质是一样的
但是操作方式（即api）有所不同
js中的arraybuffer想要操作必须针对其创建类型化数组
但buffer可以直接读写其中的数据，以任何支持编码方式。
buffer可以从任何位置读取任何数量的字节（8个字节及以内）然后按任何它支持的方式解析为相应的数据
也可以把任何支持数据按任何编码方式存储到buffer的任何位置。



作业：实现一个函数叫listRecursive(dirPath)
它接收一个文件夹的路径，返回该文件夹所有的文件的名字，注意要包含文件夹内的文件夹里的文件，依此类推
返回的是一个一维数组，内的项目是每个文件的名字（也可以是文件的完整绝对路径，也可以是相对于工作目录的相对路径）
提示：fs上的所有函数相对路径都相对于工作目录
process.cwd()可以获取当前工作目录（不一定需要这个函数）

这个函数写三个版本：同步的，回调的，promise的，async await的。


