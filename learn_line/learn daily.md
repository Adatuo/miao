# learn daily for JS

2024-7-3

函数运行的逻辑

知道了公式的求根

数组

条件里无穷大，infinity

以及，23点散步回来后似乎只能干最熟悉的事情

2024-7-5
副作用函数
纯函数，传入相同的参数总是返回相同的值
最好给函数起一个清晰的名字，后面可以重复利用

2024-7-8
2 in [1,1,1]  true 数组判断下标
21:26? 都是指向同一个元素，无论通过哪一个指向修改值，数组都会变
21:54? 修改元素实际上就是在修改指向，之前那个指向在不在没有意义
typeof null 返回object



2024-7-10
对象是值的聚名集合
2024.7.9  对象的属性 

1 in [1] false
---
push

//排序  mergeSortedArray
  nums1.sort(
    function(a,b){
      return a - b
      }
    )
//删除0,从前面删除会改变顺序，从后面开始删除  mergeSortedArray
  for (let p = nums1.length - 1; p >= 0 ; p--) {
    if (nums1[p] == 0) {
      nums1.splice(p,1)
 
    }
  }    

2024-7-12
  NaN == NaN fals
  21:07 21:12 21:53
  包装对象：一个真实的对象包装了一个原始类型
  原生对象/原始对象：直接书写的对象：“abc”

2024-7-13

//手搓concat,链接两组数，返回数组
  function concat(){
  //返回的新数组
  var result = []
  //arguments,不知道输入多少个就用这个
    for (let i = 0; i < arguments.length; i++) {
      //获得函数里面的每一个值
      var arg = arguments[i];
      //如果是数组那就遍历数字然后相加
      if (Array.array(arg)) {
        for (let j = 0; j < arg.length; j++) {
          result.push(arg[p])  
        }
      }else{
        result.push(arg)
      }
    }
    return result
}

//类数组对象 array-like object
obj = {
  length: 3,
  0: 2342,
  1: "oiwefj",
  2: false,
}


//深对比isEqual(具体内容和结构以及地址)，浅对比a===b（存储地址）

//
function foo(a, b, ...args /* 剩余参数, rest parameter, 它只能出现一个,只能出现在最后 */){
  console.log(arguments)
  console.log(a, b, args)  
}

foo(1,2,3,4,5,6,7) 返回数字和类数组对象
      1 2 [
          3,
          4,
          5,
          6,
          7
      ]

//数组排序
数组每个位置有大小，内存只要知道下标每个位置读取的时间是一样的

21：22，数组空间排序原理，内存就是这样工作的
连续空间存储。不够产生一个新空间，然后把数据拿过来。
a[23123123] = 1 不会建立这么大的空间会变为对象

c/c++/java的原始数组都是连续空间存储的
但js中的数组是特殊的对象，它的存储形式跟对象类似，但其背后肯定有连续形式存储的数组
(实际上会根据使用方式动态选择是连续存储还是对象形式存储)

//算法复杂度:
算法复杂度是分析一个算法/一段程序运行所需的时间和空间(内存)的

//时间复杂度
如何衡量程序运行的时间?
将程序运行时扫执行的所有操作的时间加起来，就是程序的总时间
实际是计算机在执行不同的原子操作的时候（如赋值、加法、乘法等）时，时间是不一样的，但是每种原子操作所花的时间是固定的，不随操作数的变化而变化
所以只要是固定时间的原子操作，我们不去纠结具体是多少时间，都统一算做一个时间单位。

但是字符串的拼接算作一个时间单位

所以
var a = 1    1
var b = 2*3 + a*a - 5    5
"fowiejfowiejf”+"oifiejfoiwejf"   1

一个算法所花时间除了程序本身，往往还取决于程序的输入。所以程序的时间复杂度往往是与输入有关的

21：53 时间复杂度的计算

有函数调用时，要看函数内部是怎么写的，包括系统自带函数

如果一个程序的运算时间最终计算出为100*n*n + 5*n + 1050 =O(*n)
如果存在一个常数c以及一个ne，让c*T(n)在n0之后始终大于F(n)则可以说F(n) =O(T(n))


粗略估算忽略无关紧要的常数，在函数图形上，O(斜线)一定会在（公式）曲线上面


//空间复杂度
空间复杂度是程序在运算过程中占用空间最多的时刻(最多同时占用的空间总数),不包括输入数据所占用的空间。
(空间与时间不一样，时间一定是累计的，但空间用过还可以清空后重复使用)即程序能够挪腾得开的情况下所需要的最小空间。

空间是不累计的，用过，清除再使用是不重复计算的。每个变量占用一个空间单位。

数组占用的空间单位数量为数组的长度

对象占用的空间是对象中属性的个教
///空间复杂度举例
function reverseArrayInPlace(array) {
var stop = Math.trunc(array.length / 2)
for (let i = 0; i < stop; i++) {
  var j = array.lrngth - i -1
  var temp = array[i]
  array[i] = array[j]
  array[j] = temp
}
return array
}

这个函数中的变量：
   ⦁ stop: 一个整数变量
   ⦁ i: 循环计数器，整数
   ⦁ j: 另一个整数变量
   ⦁ temp: 用于交换的临时变量

为什么不是 O(4)：
   ⦁ 虽然函数确实使用了 4 个额外的变量，但在大 O 表示法中，我们忽略常数。
   ⦁ O(4) 和 O(1) 在渐进分析中是等价的，因为它们都表示一个常数量的额外空间。
   ⦁ 大 O 表示法关注的是增长率，而不是精确的空间使用量。   

无论输入数组有多大，这个函数始终只使用这几个额外的变量。空间使用不会随着数组大小的增加而增加。   

2024-7-14
整数表示
20:24   想加算减 周期，通过只计算加法实现电路更简单

钟 T - 1 == T + 11

20:38 100 - 9怎么来的

//位运算
数值的二进制状态直接运算
按位与&
按位或|
按位异或^(相同为0不同为1)
按位非~ 一元运算，按位取反
移位运算
  左移 <<
  右移 >> 左边补符号位，即符号位（±）为啥就补啥
  无符号右移 >>>
    这个运算的结果一定是当正数理解的，忽略符号位

js中位运算的一些规则:
  只使用整数部分参与位运算

有用的效果:
X | 0 = X 跟0按位或不变
X & 1 = X 跟1按位与不变
X ^ X = 0 任何数跟自己异或都为0
右移相当于减半取整
左移相当于加倍

位运算非常快，快过加法


//浮点数表示
20：18 -1023-1024
20:20 浮点数在计算机中的表示
20：31 浮点数手动转换
浮点数的表示(IEEE754标准)
  JS语言里的数值其实都是有IEEE754标准存储的浮点数
    但是js中的数值在参与位运算时会保留这个数的整数部分的低32位来参与运算
  IEEE754标准中能够存储的最大精确整数为:
    2**53 - 1 大约等于  9后面15个零(书本第一章)
    即当底数部分的所有位都用来表示整数时,52 + 1位
  IEEE754中有正负零,即零有两种表示方式
  实际上NaN以及正负无穷大在IEEE754中也有相应的表示方式
    指数全1底数全0为正无穷
    符号位为1则为负无穷
    NaN也有相应的表示(略)
    虽然IEEE754中有定义这些特殊的数,但不是每种语言中都有这几个特殊数
  为什么不在底数放前指数放后?
    为什么指数部分不使用补码来存(即整数的表示)?
      为了能够从前往后按位扫描就能够区分两个浮点数的大小
        具体来说,即除符号位以外,谁先遇到1谁就更大
          可以更快的知道哪个数更大.
    为什么浮点数比大小这么重要?
      因为IEEE754不能精确表示任何一个十进制浮点数
        所以我们很少对比两个浮点数的相等性
        而是比较大小,或者是比较距离(a-b<0.0001)
      计算结果理论上相同的两个浮点数极有可能因为计算路径的不同而不一样
  为什么不存底数部分中的那个整数?
    因为那个数总是1,总是不变,就不用存了
  实际上的有效数字的数量为53位
    如果全用来存整数,则最大可以表示2**53-1,所以在这个之内的整数及其运算都是精确的
    但如果有小数部分,则整数部分就不能表示那么多了
    这意味着如果整数部分越多,则小数部分越少,那么精度就越小
      (精度说的总是小数部分,因为整数部分总是精确的(在2**53-1范围内时))
    也就是说数越大,小数部分精度就越小
    但如果全部用来表示小数,则精度可以很高
    总的来说,数越小,小数部分越精确,数越大,小数部分越不精确
  存储为的二进制状态转换为十进制时实际可以精确到小数点后53位甚至更多,但为什么只显示十几位?
    因为50几位的二进制表示的状态也就跟十几位十进制表示的状态数量差不多
    所以双精度浮点数在写成十进制时,最多也就只有十六七位的有效数字




字符串的表示
  ascii:是为每个字母,数字等英文符号指派了一个编号,一共255个符号.
  保存ascii范围内的字符,好说,直接就是这些数的二进制,一个字符占一个字节
  unicode:是为全球每个国家的每种语言的每个字符指派了一个编号
  如何保存unicode中的每个字符?
  不能直接把每个字符的编号直接转成二进制存储吗?
    理论上能,但是unicode由于编号范围太大,所以字符的编号跨度也大,a是97,"某个字符"可能是375434
    很明显的是除英文字符以外的其它的字符一个字节是不够存的
    所以要想存unicode内的所有字符,每个字符占一个字节肯定是不够的
      那每个字符占两个字节够不够?
        两个字节可以表示65536种不同的状态,显然也是小于全世界所有语言所有符号的数量的.
      那三个字节行不行?
        三节字节可以表示1670w种不同的状态,目前来说是铁定够了的.
    所以能不能每个字符就占固定的三个字节来存储呢?
      能.
    但是这样做有没有什么问题?
      有问题
      当我存的都是编号较小的字符时,空间就有浪费
      因为每个字符的编号根本就占不到三个字节.
    所以我们期望每个字符占用的字节数量是不确定的,字符号编号越大,字占的空间越多,字符编号越小,占用的空间就越小
      即**变长编码**
    如何表示当前这个字占用几个字节?
      用第一节字节来表示
        理论上可行,但有点浪费
          很明显,多数的字就只占用1 到 3节字节,你用一个字节仅用来表示1到3这三个数,有点浪费.
      用前三个字节来表示字节数量
        可以
        但是,这样一来,这种编码方式就跟ascii不兼容了
          (即ascii范围的字符与ascii编码不一样)
        而我们希望我们的编码算法能够兼容ascii,即前256或者至少前128个符号是跟ascii一模一样的
        如果数据中丢了一字节或多字节,数据会乱掉
      用每个字节的第一个字节表示后续有无字节
    实际中是怎么表示的?
      用第一个字节的**前导1的个数(前导1的后面有一个0)**来表示这个字占多少个字节
        多字节符号后续的字节以10开头
      单字节字符以0开头(兼容ascii 128以内的字符)
        1.	单字节字符（0xxxxxxx）：
	          	对于单字节字符，最高位是 0，即字符编码在 0x00 到 0x7F 之间。这部分与 ASCII 兼容。
	      2.	多字节字符：
              对于多字节字符，首字节的前几个比特用于指示字符的长度，后续字节以 10 开头。
              双字节字符（110xxxxx 10xxxxxx）：
              第一字节的前两位是 110，表示这是一个双字节字符。
              第二字节的前两位是 10，表示这是一个后续字节。
        3.	假设我们要编码一个字符，其 Unicode 代码点是 U+263A（）：
            •	U+263A 的二进制表示为：0000 0010 0110 0011 1010
            •	根据 UTF-8 编码规则，需要三个字节来表示这个字符：
            •	首字节：1110xxxx（前三位是 1110，表示这是一个三字节字符）
            •	第二字节：10xxxxxx
            •	第三字节：10xxxxxx
          将 U+263A 分割为三个部分并填充：
            •	1110 0000
            •	10 100110
            •	10 001110
          结果是：1110 0010 1011 0001 1010，最终 UTF-8 编码为 E2 98 BA。      
      变长变码(连编码这个字符占几个字节的部分都是变长的)
      可以在丢失字节时,不打乱后续的字符(因为每个字符的后续字节必须10开头,不是10开头则说明是下一个字符了)
        (即,可以通过这个后续字节10开头来识别字节的丢失)
    以上就是UTF8编码
    需要注意UTF8与UNICODE不一样
    unicode是为字符指派编号
    utf8是对编号进行二进制的编码
    类似的还有utf16编码,每个单位是16字节,首个编码单元的前导1的个数表示这个字的编码单元数量
      (这里的编码单元对于utf8来就是1字节,对于utf16是两字节)
 11:06:33
要将小数 3.25 转换为二进制，并了解其在字符中的表示，需要进行以下步骤：

### 步骤 1：将整数部分转换为二进制
整数 3 转换为二进制如下：
- 3 ÷ 2 = 1 余 1
- 1 ÷ 2 = 0 余 1

从最后一个余数向上看，得到二进制数 11。

### 步骤 2：将小数部分转换为二进制
小数 0.25 转换为二进制如下：
- 0.25 × 2 = 0.5 → 整数部分为 0
- 0.5 × 2 = 1.0 → 整数部分为 1

所以，小数部分 0.25 的二进制表示为 0.01。

### 步骤 3：合并整数和小数部分的二进制表示
将 3 的二进制表示 11 和 0.25 的二进制表示 0.01 合并，得到 3.25 的二进制表示为 11.01。

### 字符表示
在计算机中，浮点数的二进制表示可以通过 IEEE 754 标准来表示。具体步骤如下：

#### 1. 正规化二进制表示
首先，将二进制表示 11.01 正规化为 1.101 × 2^1。

#### 2. 计算指数部分
根据 IEEE 754 标准，32 位浮点数有 8 位用于指数部分，用偏移量 127。计算 1 + 127 = 128，二进制为 10000000。

#### 3. 尾数部分
取小数点后的部分 101，填充至 23 位为 10100000000000000000000。

#### 4. 组合
- 符号位：0（表示正数）
- 指数部分：10000000
- 尾数部分：10100000000000000000000

组合后，3.25 的 32 位浮点数表示为 0 10000000 10100000000000000000000。

### 最终字符表示
将这个 32 位二进制串转换为十六进制，可以得到其字符表示：
- 二进制：0 10000000 10100000000000000000000
- 十六进制：0x40400000

综上，3.25 的二进制在字符中的表示为 0x40400000。

 11:06:35
### 指数的偏移量 (Bias) 解释

在IEEE 754浮点数标准中，指数部分存储的是一个带偏移量的值，以便能够表示正负指数。以下是详细解释和计算步骤：

#### 1. **偏移量的概念：**
指数的偏移量 (Bias) 是为了能在二进制表示中表示负数和正数。偏移量的值取决于指数部分的位数。

- **32位单精度浮点数:**
  - 指数部分占8位。
  - 偏移量: ,( 2^{7} - 1 = 127 ,)

- **64位双精度浮点数:**
  - 指数部分占11位。
  - 偏移量: ,( 2^{10} - 1 = 1023 ,)

#### 2. **如何计算实际指数：**
实际指数 (E) 是用来表示浮点数的次方数。存储在内存中的指数值 (E') 是实际指数加上偏移量。

公式如下：
,[ E' = E + ,text{Bias} ,]

- 对于单精度:
  - ,( E = E' - 127 ,)
- 对于双精度:
  - ,( E = E' - 1023 ,)

#### 3. **示例计算：**

以3.25为例，解释其转换过程：

- **二进制表示：**
  - 整数部分 (3): ,( 3_{10} = 11_2 ,)
  - 小数部分 (0.25): ,( 0.25_{10} = 0.01_2 ,)
  - 合并后，3.25 = ,( 11.01_2 ,)

- **标准化：**
  - 标准化二进制数: ,( 11.01_2 = 1.101 ,times 2^1 ,)

- **指数计算：**
  - 实际指数 (E) = 1
  - 存储的指数值 (E'):
    - 对于单精度: ,( E' = 1 + 127 = 128 ,)
    - 对于双精度: ,( E' = 1 + 1023 = 1024 ,)

- **IEEE 754表示：**
  - 符号位: 0 (正数)
  - 指数部分:
    - 单精度: ,( 10000000_2 ,)
    - 双精度: ,( 10000000000_2 ,)
  - 尾数部分:
    - 尾数为二进制小数点后的部分，1.101 的尾数是 101

### 完整的浮点数表示：
- **32位单精度：**
  - ,( 0 10000000 10100000000000000000000 ,)

- **64位双精度：**
  - ,( 0 10000000000 1010000000000000000000000000000000000000000000000000 ,)

### 偏移量的作用：
在上述过程中，偏移量（Bias）的作用是将实际指数 (E) 转换为非负数的存储指数 (E')，以便在二进制系统中容易表示和处理。

### 总结
指数的偏移量是在二进制表示浮点数时用来处理正负指数的技术，通过增加一个固定的偏移量，使得所有的指数都变为非负数，这样可以在二进制系统中表示。32位和64位浮点数使用不同的偏移量以适应不同的指数位数。

7-17

# 箭头函数
[1,2,3,4].forEach(it =>{
  console.log(it)
})

# 高阶函数
## 定义：高阶函数是指接受一个或多个函数作为参数，或返回一个函数作为结果的函数。
### 当一个函数操作它函数时(不管是拿它们当参数，还是返回一个函数)
特点：

	1.	接受函数作为参数：高阶函数可以接收其他函数作为参数。
	2.	返回函数：高阶函数可以返回一个新的函数。

function add(a,b) {
  return a + b
}
## 多参数返回
function noisy(f) {
    /*第一个 return 语句返回的不是传入的参数，而是一个新函数。
  这个新函数会在调用时打印传入的参数并返回计算结果。*/
  return function (...args) {//搜集参数，都会返回数组
    console.log("call with",args);
    var val = f(...args)//返回参数，都会返回数组。等价于f.apply(null,args)
    console.log("call with",args,"- got",val);3,5 ,8
    return  val;
  }
}


let noisyAdd = noisy(add)
noisyAdd(3,5)

## 现有function forEach，接下来的高阶函数才有用
function forEach(array,doSomething) {
  for (let i = 0; i < array.length; i++) {
    doSomething(array[i],i,array)
  }
};
forEach([1,2,3,4],function(it,idx){
  console.log(it,idx);
})


#求导(f)
function 求导(f){
  return function(x){
var gap = 0.000000000001
var xl = x - gap
var x2= x + gap
var y1 = f(x1)
var y2= f(x2)
return (y2 - y1)/(x2 - x1) ≈ y2 - y1 = k(x2 - x1)
  }
}

# 闭包
[text](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)


7-19
# JOSN
配置文件 ini
yaml语法不一样
反引号 ` `里面可以打回车 

 不能有Tab

  json中不能有运算，但是js对象可以

  json中对象的属性名必须加【双引号】
  但js中的对象，属性有时可以不加引号，加也可以加单引号(不能用反引号)

  js中对象或数组最后一项的后面可以为了美观/对称/一致而多加一个额外的空格json中不行

  json中只有对象，数组，数值，字符串,，null没有NaN，没Infinity,
  但是有科学记数法

一个json文件的内容可以对应于一个类型的值以下均为合法的json文件
---
2
---
true
---
"owierjuowiefj"
---
[1,1,1,2,3,3, "oiwejf"]
---
{
"a":·1,
"b":·[2,3,{}]
}
---

为什么有这样的限制?
1.是为了让json格式更简单，则更容易解析
2.是为了让json格式能够适应于更多的语言(json中支持的值的类型几乎所有语言都支持)

## JSON.stringify JSON.parse
JSON.stringify 将 JavaScript 对象转换为 JSON 字符串。JSON.stringify(value[, replacer[, space]])

JSON.parse 将 JSON 字符串转换为 JavaScript 对象。JSON.parse(text[, reviver])


## trim()
对于josn特别有用，用于去除一个字符串两端的空白字符和行终止符(中间的无法去除)。这个方法不会改变原始字符串，而是返回一个新的字符串。
---
去除的字符：
空格 (' ')
制表符 (',t')
行终止符（包括 ',n'， ',r' 等）
---
let str2 = ",t,tJavaScript,t,nttt";
console.log(str2)
let trimmedStr2 = str2.trim();
console.log(trimmedStr2)//JavaScript

# slice()
用于从一个字符串或数组中提取一部分，并返回一个新的字符串或数组，而不改变原始字符串或数组。
// 对于字符串
let str = "Hello, World!";
let newStr = str.slice(0, 5);
console.log(newStr); // 输出 "Hello"

// 对于数组
let arr = [1, 2, 3, 4, 5];
let newArr = arr.slice(1, 3);
console.log(newArr); // 输出 [2, 3]

# split()
用于将一个字符串分割成子字符串数组，并返回该数组。该方法不会改变原始字符串。
let str = "apple,banana,cherry";
let fruits = str.split(",");
console.log(fruits); // 输出 ["apple", "banana", "cherry"]

let str2 = "a-b-c-d";
let letters = str2.split("-", 3);
console.log(letters); // 输出 ["a", "b", "c"]

# filter
filter() 是 JavaScript 数组对象的一个方法，用于创建一个新数组，包含所有通过所提供函数实现的测试的元素。filter() 不会改变原数组，只会返回一个新的数组。
## 用法
let newArray = array.filter(function(element[, index[, array]]){},thisArg)
Array.filter(function(currentValue, indedx, arr), thisValue)
## 参数
function: 一个用来测试数组每个元素的函数。它接收三个参数：
  element: 当前处理的元素。
  index (可选): 当前处理元素的索引。
  array (可选): 调用 filter 的数组。

thisArg (可选): 执行回调时用作 this 的值。


# map
map 是 JavaScript 数组的一个内置方法，用于创建一个新数组，其结果是通过对数组中的每个元素调用提供的函数来实现的。map 不会改变原数组，而是返回一个新数组。
## 用法
const newArray = array.map(callback(element[, index[, array]])[, thisArg])
Array.filter(function(currentValue, indedx, arr), thisValue)
  callback：在数组每一项上执行的函数，接收三个参数：
  element：正在处理的当前元素。
  index（可选）：正在处理的当前元素的索引。
  array（可选）：调用 map 方法的数组。
  thisArg（可选）：执行回调函数时用作 this 的值。

# map与filter的不同
map 用于对数组的每个元素进行变换，返回一个新的数组，长度与原数组相同。
filter 用于筛选数组中的元素，返回一个新的数组，长度可能小于或等于原数组。

# reduce
reduce 是 JavaScript 中的一个数组方法，它用于将数组中的所有元素通过一个累加器函数逐步合并为单一的输出值。
## 用法
array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue);
  callback：一个函数，用于对数组中的每个元素执行。
  accumulator：累加器，累积回调的返回值。
  currentValue：数组中正在处理的当前元素。
  currentIndex：数组中正在处理的当前元素的索引，从0开始。
  array：调用 reduce 的数组。
  initialValue：作为第一次调用 callback 函数时 accumulator 的初始值。如果未提供 initialValue，则使用数组中的第一个元素，并从第二个元素开始执行 callback 函数。
## 例子
[4,4,5,3,2,7,8,88,8].reduce((avg,it,i) => {
  return (avg * i + it) / (i + 1)
})
[2,3,5,7,11].reduce((obj,it,i) => {
  obj[it] = i
  return obj
},{})

7-20
# map、filter、filter结合
## 会占用更多内存
var avg = (avg,it,i) => (avg * i + it) / (i + 1)
ancestry
  .filter(it => it.sex == 'f')
  .map(it => it.died - it.born)
  .reduce(avg)
# bind
function add(a, b) {
  return a + b;
}

const addFive = add.bind(null, 5);
console.log(addFive(10)); // 输出: 15，因为 `a` 已经绑定为 5
## 总结
bind 方法在以下情况下特别有用：

  需要确保函数在某个特定对象的上下文中执行时。
  创建带有部分应用参数的函数（即柯里化函数）。
  为回调函数绑定 this。
#
优雅与效率二选一
bind 可以套娃绑定
21：32面试要问
22:25面试
时间复杂度 空间复杂度判断

7-21
21:10
every2 some2 predicate
Count Primes 22：04 22：06更快
MoveZero 思路不一样 22：13

8-1
21:15继承
21:50super()
22:20对象类型判断

8-2
21:10 递归二叉树
21:25 数组

8-3
21:00 with
21:15 eval
21:20 arguments
21:26 callee

8-4
class1  向上抛出异常
22:00 断言
简言之，断言就是如果ok，就什么也不做，如果不ok，就直接抛错
8-5
20:33 新购函数
20:35 用JS写python的with
21:22 depth虽然没有但是数组也可赋值 

8-6
20:00 写在里面的函数,写在函数里面的函数,通常不返回东西.一般来说只是为了达到**某种效果(比如循环)且不需要这个函数的返回值.最好不要写在if里面,或者使用外函数的某个参数**  类似闭包但不是
内层函数不会让外层函数结束

3.复杂度分析(重要)


21:00 稀疏数组,方便push
不是连续存储，不用关心长度的数组，可以随意增加或者减少长度
即使前面是空属性，push也会放在空属性的后面


21:10 二叉函数排序.链表不能用二分法
22:00 排序,高阶
22:20 知道两个二叉树还原前中后序二叉树

8-7
21:50 堆排序
|10 0 向下取整

8-9 
20:26 哈希冲突的三种解决方式,链式存储
JAVA红黑树用来自动平衡排序二叉树的深度的链式存储,以解决哈希冲突
21:45 扩容与缩容

8-10
递归变量,需要一直调用一个新的变量放在函数里面.需要这个变量不变一直使用放在函数外面

8-11
21:00 各种排序的稳定性
21:25 排序的稳定性意义(excel排序)

8-12
20:58 ^
22:08 dayjs momentjs 日期正则表达式
22:22 各种零宽断言 $ ,b ^ ([^a-c]不一样)
      positivelookahead（?=xxx）正预测先行断言 某个位置的右边要是xxx
      negativelookahead（?!xxx）负预测先行断言 某个位置的右边不能以任何形式匹配xxx
      positionlookbehind（?<=xxx）正回顾后发断言 某个位置的左边要是xxx
      negativelookbehind（?<!xxx）负回顾后发断言 某个位置的左边不能以任何形式匹配xxx
      零宽断言连续使用时断言的是同一个位置 
      /(?<!.)/ == ^ /(?<![^])/
      /(?!.)/ == $ /(?![^])/
      /(?!,w)|(?<!,w)/ == ,b
https://regex101.com

8-13
21:24 replace 重复替换 表示所有?
21:35 replace(/ /,function(mathch,amount,unit))
22:05 正则表达式函数
22:24 分组

8-14
20:49 可能的面试题
21:13 动态正则多种语言转换的时候出现(差不多这个位置就飘走了)
21:18 lastINdex
22:08 非捕获分组 防止/(?:)/非空
22:12 10遍 

/(.),1+/ == '(.),1+' 
,1 : ,1 是正则表达式中的反向引用，它引用的是在当前正则表达式中第一个捕获组的内容。反向引用允许你在正则表达式中重新使用已经匹配的部分文本，从而实现更复杂的匹配逻辑。

反向引用的工作方式：
	1.	捕获组：
	•	捕获组由括号 () 定义。正则表达式中的每一对括号会捕获匹配到的内容，并将其存储在一个临时的内存中，供后续使用。
	•	例如，正则表达式 /(.)/ 会捕获任意一个字符。
	2.	反向引用：
	•	反向引用使用 , 后跟一个数字来引用捕获组。,1 表示引用第一个捕获组，,2 表示引用第二个捕获组，以此类推。
	•	反向引用在正则表达式中可以被用来匹配捕获组中已经匹配到的相同内容。

示例：

假设你有一个字符串 "abcabc"，你想匹配两个相同的连续子字符串，比如 "abcabc"。可以使用如下的正则表达式：

const regex = /(abc),1/;
const str = "abcabc";
const result = regex.test(str);
console.log(result); // 输出: true

$&：在 replace 方法的替换字符串中，$& 代表正则表达式匹配到的整个字符串，即整个匹配结果。

使用示例：

假设你有以下字符串，并想用 [] 包裹所有匹配到的单词。

const str = "Hello World";
const result = str.replace(/,b,w+,b/g, "[$&]");
console.log(result); // 输出: "[Hello] [World]"

math
math.index
math返回的是数组,但是match[0]访问的是所有个元素
var input = "A string with 3 numbers in it... 42 and 88.";
var number = /,b(,d+),b/g;
var match;

while (match = number.exec(input)) {
    console.log("Found", match[1], "at", match.index);
}

	•	这个正则表达式匹配的是字符串中的所有独立的数字（3, 42, 88）。
	•	在每次匹配时，match[1] 包含匹配到的数字部分，而 match.index 则表示该数字在字符串中的起始位置。



8-15
21:14 hover,正则
21:19
21:35 零宽断言 hover

8-16 20:00 raw
raw
不自动处理转义字符串
String.raw`,naa,2` 必须是反引号
',naa,2'
log -> ,naa,2
20:20 String 的 raw怎么写的
20:21 想写其它语言的代码可以用字符串括起来
20:25 单个反斜杠不能放到最后 ` ` 即加上一个反斜杠使得字符合法
20:30 this?调用对象
22:00 IP回溯
深度不确定'回溯'

8-17
json解释器
20:38 parseInt Number
20:51 parse就是递归下降的过程
21:16 json也可以表示函数
21:33 参数调用 
21:59 语法树
22:13 ...arg的点
22:29 parse 解析器的题目
the-super-tiny-compiler

8-18
20:05 什么是去中心化
21:03 Document DOM
21:21  节点
21:27
21:55 文本节点一个一个找,不能连续 

8-19
20:48 elt
20:50 Pauseonuncaughtexceptions
20:55 创建
21:00 其实也只有两个htmlFor classNmae 属性
21:09 data- 避免与现有属性冲突
21:12 dataset 直接访问带有data- 的标签
21:48 结束标签
21:54 浏览器布局
22:02 布局什么时候计算,调用或者读属性的时候会动态计算布局.按需计算
22:16 flane graf 性能图 清楚知道每个命令怎样在运行,耗时多久(面试重点)
22:21 样式计算

8-20
20:35 选择器是在全局范围内match
      可以选择一部分伪类
      不能选择伪元素
      返回静态集合，不会动态更新
      document.querySelector() 只会返回一个元素,一个DOM
      querySelectorAll()[0] 会返回数组
20;53 会更新布局但是不会画出来,js最终结束会计算布局
21:14 paint js运行的时候不会画,显示器显示不出  Layout布局一定会计算
21:19 有时候会暂停
21:30 16毫秒
21:32 requestAnimationFrame转不停(递归)
21:40 离开界面就不转了
21:45 作者的离开界面后,计算离开时间,再动(以其其他的动画解释)
22:13 innerHTML
22:18
22:21 classList.remove 方便操作类名

8-22
21:06 'clik' 不要打空格 
21:08 clik的几种绑定方式 
21:07 移除 注意:没有添加名字的话就是全局,要在全局解绑
21:10  sun.onclick = function(){ console.log(11)} //只能绑定一个
21:12 直接在标签里面添加onclick
21:23 onmousedown 不分左右键event which会记录1左2滚轮3右键 type记录事件名称
document.body.addEventListener('click'，function(e)){}
//如果一个函数是事件处理函数，那么此次运行它是在做为谁的事件处理函数运行，它里面的this就是谁
21:27 一部分元素能收到其子元素的事件(除了long和change)
21:39 事件的传播(冒泡)与阻止
      stopPropagation() ---
      stopImmediatePropagation()阻止事件在当前元素上进一步执行（即后续的处理函数都不执行了）
21:51 target指向了事件发生时最原始发生的元素
22:00 mathes 事件委托(代理) target事件来源结点
22:04 面试题
22:13 箭头函数混淆的括号
22:17 循环体有几次就有几个i , 外面的i是为了保障运行 , 里面是保障click
22:20 一般大量元素才这样做 let 与 var
22:22 更好的办法 变成数组

8-23
事件代理??
20:05 从外向内.叫做,事件捕获 captrue 
20:18 从外向内,再从内向外 先捕获再冒泡 排序?
20:22 默认行为
20:26 事件的运行
20:31 一些快捷键
20:42 按键分左右
21:00 key的各种事件属性
21:09 焦点
21:11 log
21:14 鼠标事件
21:16 鼠标特殊的触发机制
21:25 span
21:40 鼠标移动事件
21:54 which button,二进制计算 1 11 111
22:00 button & 1
22:07 有可能会被冒泡影响
22 14 contens
22:17 现在一般都用 mouseenter mouseleave 这也是有些事件不冒泡
22:21 被动事件{passive:false}

8-24
前10几分钟,滚动事件
16:12 滚动事件与其他事件的不同
16:18 mousewheel滚轮事件,可以阻止滚动与其他事件的运行一样
16:20 聚集事件
16:25 一些添加?
16:29 fields[i] 重要
window也有focus,在线考试
16:33 加载事件
16:38 因为页面要加载,最好把script写到最后,加载完后再运行
15:39 src如果运行时间过长会先把页面画出来再加载,但是确实在一些情况下一边加载一边绘制页面
16:54 几个事件的运行细节(面试)
解析dom，运行js（可能修改DoM，如果js读取布局信息也可能触发浏览器forcedreflow），计算布局，绘制页面
这几件事件，对于某一个页面来说，浏览器只干其中之一
16:57 script 里 async 谁先加载完谁运行 defer按顺序运行(面试) 不会等到script加载完后运行
17:00 啥来着?
17:04 没加载完成也照样绑定事件
17:06 DoMContentLoaded 这个事件在dom解析完毕的时候触发
      readystatechange 它会在开始解析dom的时候触发一次，解析完成的时候触发一次
      简称为dom ready事件
17:17 滚动到哪里图片才加载 图片按需加载 再
17:40 浏览器每个时间在干嘛
17:46 事件的执行 event -> function -> event 滚轮event -> event -> function
17:55 线程 这节课不太好理解
18:10 woker可以设置多线程,可能现在不行了
18:20 woker监听外部来的消息
一般在正则表达式用woker

8-25
20:07 Threads 第一节
20:18 postMessage 返回调用的人
20:20 worker在mini-regex的调用
 data-tabname ?? data?
20:43 false
21:06 定时器 会返回一个ID 可以调用此ID清除定时器
21:14 setTimeout = setInterval  0 没有即刻调用的用法,现有的代码执行完后才会运行
21:18 一些细节
21:20 Debouncing
21:23 防抖(面试)
21:25 防抖代码(面试)
21:30 节流 降低操作频率
21:33 节流的代码 书本 至少间隔一定的秒数(面试)
21:38 什么时候防抖(存盘,保存用户输入),什么时候节流(获得鼠标位置,但是不要那么频繁,窗口的调整) (面试)
21:55 防抖 手搓
21:59 节流 手搓
22:06 Summary 
22:14 补充的事件
22:19 补充事件2
lodash  matches 与 matchesProperty 的区别 chuanxin做法
8-26
20:00 lastLastindex错误
20:14 clipboardData 事件完成后就消失了
20:46 劫持  先经过我设置的属性,然后在给到浏览器
20:52 如何拿到原型的value
20;56 劫持流程
21:01 所有在前端挡都是不靠谱的,在接收端(服务器上挡最靠谱)
21:16 永远要检查用户的输入
21:27 画鼠标
21:32 节流减少鼠标图片
21:39 浏览器与系统清除内存对象的异同
21:40 对鼠标时快时慢进行分析 有可能是鼠标问题 也有可能是触发的问题

8-27
20:14 zindex
20:27 user-select
20:30 ??父元素?
20:36 cursor  鼠标方向css元素
20:45 拉完后要解绑
21:03 children死循环怎么回事21:06解决
21:36 jQuery
21:45 jQuery的一般流程
21:47

8-28
20:01 es6是什么
20:09 TDZ Temper Dead Zone ??
20;15 三种声明方式
10:16 const 的变量是常量 但是常量指向对象,对象就可以修改
20:18 想让对象也不能改动怎么办?(面试)Object.defineProperty
20:20 
Object. preventExtensions (obj)阻止对象新增属性
Object.freeze（obj）完全冻结对象（但不是递归?冻结）
Object.seal（obj）阻止对象的属性集合发生变化（即不能增删
属性，但可以修改属性的值）

is??

20:28 Unicode `` 里面是表达式或者函数 foo``
html`
<div><div>
` 一般用来包不是这个语言的代码
20:32 Function
set必须且只能生成一个参数
20:34 get:function() set:function() value
20:38 构造函数的奇怪使用
20:40 展开运算符...
20:41 name
20:44 new 的 name 与 变量 = function() name的区别
20:47 属性名 变量名也会被选座名字
20:58 函数的4中情况(箭头)
21:01 new.target
21:02 箭头函数与普通函数的区别(面试)
箭头函数后面不能立即跟括号,括起来再跟就可以
21:04 super
21:10 IIFE(面试) 这是?
21:15 调用优化  尾调用优化 减少栈空间 单独一个函数调用才行
21:33 对象扩展 
21:33 对象的4种分类
21:40 对象语法拓展 
21:42 21:54对象声明的省略
21:55 Object.is
21:56 Object.assign
21:59 Object.assign的使用场景
Object.isExtensionable (obj)
Object.isFrozen (obj)
Object.isSeal (obj)
22:03 对象里面写super,调用的是原型的
22:05 Destructuring 解构赋值 数组,对象都可以一直套,...,变量声明
22:22 Obje.entries
22:23 Symbol  一种唯一性 或者作为属性名 要读到它必须对应的属性名才可以
22:34 Object.getownPropertySymbols(obj)获取对象的Symbol集合
22:38 Symbol.for(str)

8-29
20:00 迭代器与生成器
20:02 生成器函数 生成出若干个值 function * () yield
20:24 next何时传参 第一次不用
20:27 yield还可以抛出错误
20:37 [... ] 一直next
20:39 生成器的for of
20:53 不同的控制流
20:59 生成器的一些方法
21:04 生成器相互调用
21:11 range
21:18 for of 的运行逻辑
21:22 对象与生成器
21:15 Symbol.iterator 只有next方法
21:28 多数函数是返回迭代器返回 迭代器
21:42 面试题 for(var x of 9)
21:48 面试题 对象可以for of 吗
21:55 静态方法
22:02 静态属性
22:03 Proxy
22:07 Proxy各种属性
22:13 revoke
22:15 apply
22:18 Reflect
22:25 ?? 双问号(非常好用) 可选链
22:27 bigint  要传字符串,太大的数本身就会丢进度

8-30
20:02 表单form和字段input,textarea,select,button,label
20:14 input一般只能单行
20:20 输入过程探测input改变
20:27 selcet()选中内容 blur()失去焦点 focus()获得焦点
document.activeElement 焦点所在元素或者最后焦点所在元素
DOMContentLoaded 比 onload更早()不用加载图片
20:52 禁用 
20:53 draggable
XMLHttpRequest elements 属性主要是 HTML 表单元素 (<form>) 的特有属性，用于访问表单内的控件集合
21:11 文本框
selectionStart selectionEnd 光标选中的信息,没有选中就闪烁
21:31 复杂度不会消失只会转移
21:41 chrckbox name分组
21:45 radio name分组 value不同
21:49 下拉框
21:52 select其实是可以多选的
22:11 文件选择框 multiple
22:18 MIME 媒体类型

8-31
20:20 客户端保存数据
20:40 每个网站都有一个只存储字符串的迷你硬盘 localstorage文件
21:22 storage事件?
21:30 如何解决数据不同步的问题? 刷新界面,太笨方法
21:36 产品思维
21:38 Summary
21:44 想要使用文件而不是获取文件的内容时
21:45 sessionStorage一般不用这玩意
22:12 导出数据实现
22:19 ES6 扩充数组方法之Typed Arrays 
22:24 Typed Arrays 一般用来获取最原始的信息读出来,处理二进制 是在内存里面的连续下标存储 可以设置存储字节
1字节 16bit -127-127 0~255
2字节 16bit -32768-32768  0~65535 不同的字节,比特位和存储空间的不一样
字节（Byte）是计算机中存储数据的基本单位之一，一个字节通常由8位（bit）组成。位（bit）是计算机存储的最小单位，表示0或1两种状态
22:29 不同字节存储空间不一样
22:32 ArrayBuffer
22:41 Blob  固定长度的内存存储的数据,但是不能读取  

9-1
# BOM
API 就是应用编程接口
20:08 什么是BOM
20:14 Blob
20:17 screen  屏幕 20:21 各种方法 一般只看height width
20:23 location 浏览器地址栏
20:25 地址栏的各种含义
20:32 location赋值字符串但还是对象
20:34 onhashchange hash变化不会重新加载
20:38 带有#hash的请求和不带都是一样的

location.assign(url)·<=> location.href = url <=> location·=
url

20:51 浏览器前进后退模型 replace
20:58 a标签与location
21:01 面试题 simplifyPath
21:03 navigator.userAgent 用户代理字符串 与浏览器有关的版本信息
21:14 浏览器UA是可以修改的
21:16 window.name 窗口名字与页面没什么关系
别取全局变量名
21:24 window.open
21:29 window.opener 可以用这个接口实现两个界面通信postmessage
21:35 stop
21:39 window.getcomputedStyle 一般来讲直接去该内联样式
21:51 history 只是当前窗口的前进后退以及点击产生的记录
21:53 pushState 
21:57 history.pushState history.state增加页面前进后退状态
popstate  会知道后退时候的状态
22:09 手机上前进事件很少
这一套api是用来方便你管理“不刷新且交互复杂的页面"的状态........
22:12 演示,不刷新
22:14 deep link (面试题) 一个链接,链接到深层次界面去
22:17 不刷新且交互复杂的页面,可以使用hash和hashchange事件模拟出来
22:18 replace

9-2
20:37 自定义时间
20:53 安全分析
20:55 iframe,作者实际上开了 就是不同作用域
21:03 不要把用户输入的代码放到自己的作用域执行创建一个虚拟的
21:14 自动联想搜索框
21:21 settimeout
21:24 时间线
21:40 foo
22:23 九宫格遍历法

9-3
20:31 取巧的对比方式
20:34 json不能转换带环的 c.c
21:15 这种图就表示性能不太行了
21:21 如何更快绘制游戏
21:24 canves的内存很小也没有样式,所以更快
21:29 改变的画法
21:37 丢帧分析 可能的结论:改成ArrayBuffer数组
21:47 另一种画法
22:12 优化
22:22 用内存画颜色就更快
就一个是画一个图个色(相当于每画一个就多一个DOM),另一个是先算好内存中的颜色再一次性涂上去

9-4
20:16 window.getSelection()
20:19 firefox可以有多个选取
20:22 anchorNode选区起点  (选区只能选择文本节点) 正反选text会有标注 text里的dom标记了是从哪一个字符串开始数数的
extentNode选区终点  
20:30 光标位置分析
20:56 restoreCursorPosition还原光标位置
21:06 为何光标能正好在后面,打出来后才会run
21:23 mouseout 冒泡的
21:28 getclientRects
21:31 代码的细节?
21:59 选择方便转换的进制 ACLL64合适
22:02 字节进制怎样快? => base64编码
22:06 填充 =
22:09 如何转换的 16进制转换二进制 6个一组按照表对应
22:22 dataURL的格式
22:27 padStart 可以补刀想要的字符长度
reaAsText 转为一个字符串

9-5
20:04 实现画铁路图功能
20:07 正则表达式的三种语法  顺序 选择 递归
20:10 正则是如何嵌套(递归)的
20:16 整体的分割

9-6
20:03 SVG 有默认宽高 太小可能显示不全
rect
circle
描边stroke 颜色
stroke-width  描边粗细
polyline 折线
ellipsis  椭圆
后面的元素会盖住前面的,且不能设置index
path标签 <path d="M L C S T Z A"></path> 图形指令标签 //要把绘图指令想象成控制画笔 
20:35 贝塞尔曲线
描边填充都是一个的话可以用一个path画出来
text 对其左上角定位
21:15 不同的标准下标签命名空间可能不一样
21:22 XML语法
21:28 SVG的图标比字体图标更生动
21:35 symbol引用SVG标签,这样要把symbol套入svg(最好用font伪元素,要么用unicode)
21:38 DOM(canvas)画,但是不能清除,因为编程接口不能撤销,直接转成了像素 
21:41 显存,屏幕画图原理 x*y*3

## 9-7
通过解析的语法树画图
20:16 各个画图的部分
20:30 getBBOX
21:08 简化getBOx
21:13 get set 不能...展开
21:16 g标签不能通过x y偏移 要用transform
21:19 0-9 /d  自己写
21:35 加宽就再加一个rect块
21:44 *6 ?
21:48 考虑线条问题 结论所有水平线都穿过中间
22:07 为什么用贝塞尔曲线画 圆弧画可能空间不够
22:22 ?

## 9-8 解决g靠不到边的问题,因为g标签还要成为别人的子元素,21:33(很重要)

## 9-9 
# 网络
20:06 拓扑结构
20:07 分层结构ISO
20:16 网络层次
20:23 令牌环网络
20:32 星网络  任何一个设备发送其它都可以接收,效率低 集线器
20:36 总线网络  指数等待,效率还是低 虽然有网卡检测是不是给自己的数据,但是可以修改 集线器
20:43 MAC地址,网卡地址  Media Access Control 媒介访问控制
20:56 交换机与集线器 ? 交换机总线优化版
21:01 在交换机网络中，主机并不知道自己在交换机网络中(它认为自己依然在总线型网络中) 原理与总线一样
交换机只需要一张控制器或者网卡检测网口的数据到哪一个网口
21:12 网线最好按照顺序绑  
21:13 双绞线就是为了抗干扰
21:17 网线是数字信号,其它都是模拟信号
21:20 信号的传递,高低电压
21:28 从高跳到低,每个比特的跳变周期来确定1 0
21:30 网卡会有识别 曼彻斯特编码
21:33 速率一般就是1M bit 时延 RTT:发出去再收回来的时间
21:35 链路层  以太帧网络图bing
21:36 数据包R发出 S接收 DATA数据 ?
21:42 前导码同步时钟
21:44 以太帧 压缩包校验码CRC ,网线连接的地址
21:57 不同链路层实现方式
22:00 4G 5G频段不同 5G更宽,不用挤在一起速度也就不同 
22:07 MAC地址,也叫物理地址
22:13 局域网是通过MAC来通信的 通过ARP 地址解析协议吧IP转换成MAC地址
22:17 ARP协议原理 广播一边(包着MAC)问一下是谁需要MAC 仅仅在直连设备使用
22:23 ARP欺骗
22:26 如何解决ARP欺骗,依据MAC地址 高级交换机就有这个作用
22:36 如何判断是否在同一个网段 子网掩码 
把ip地址转换为一个uint32的整数

## 9-10
20:21 路由器
20:32 路由器与交换机数据包的传输过程
20:36 IP地址是给到网卡的
20:40 IP地址与地区绑定
20:46 开头的好处  不需要记住所有IP只需要记住开头就行
20:49 IP与定位有关,同一个地球2长得差不多
21:17 包格式
21:30 抓包是tracert,可以知道是通过怎样的现实路径到达的目的地
21:34 数据包1480字节  大于的话多发一个
21:37 网络层
21:46 ICMP,直接基于IP协议
22:03 WIRESSHARK
22:15 ABC类地址
22:30 DHCP如何获取的  全部问一句谁有IP给我一个,(有可能会有多个设备相应)然后将地址单播返回 一般路由器干这个
22:43 IP地址存在与分配
22:46 DNS 让名字指向IP地址

## 9-11
20:10 DNS服务图
20:16 大公司才用不同区域的DNS解析
20:20 DNS负载均衡?
20:23 VPN 虚拟专用网络  网络层
20:33 一条虚拟网线直接连接到公司内部网络服务器,更快更安全
20:35 VPN就是这么回事
20:42 IPV6
21:05  IPV6 OVER IPV4
21:14 IPV6格式
21:21 传输层(TCP/UDP)
21:30 UDP 
22:03 UDP总结
22:15 两个IP 用哪个网卡发就是哪一个IP
22:18 DHCP基于UDP 
22:21 发什么端口就回到什么端口
22:24 DNS 53 DHCP 67
22:27 回发
22:28 ping
22:35 hosts
22:39 动态DNS服务 DDNS 发现自己的IP被修改了,就自动修改指向

## 9-12
20:01 NAT 网络地址转换
20:05 网络层路由器与家用路由器(NAT路由器)是不一样的
20:07 NAT路由器
20:23 替换IP 路由器的出口都会替换成广域网的IP
20:30 通过端口,回到发出来的机器 图
20:34 同时发怎么办? 端口号+1 (或者说空闲的端口帮助转发)
20:35 端口映射(转发)
20:27 几种情况,不同NAT类型
20:43 端口一段时间不使用会删除
21:09 路由器收到的不能直接转给设备(内网可以主动连接外网,外网不能直接访问内网),但是可以设置静态IP或者DMZ
21:14 不能直接转给设备的好处,免受攻击
21:16 IPv6所有设备都暴露在公网,是否有安全隐患 实在太多,遍历成本无限高
21:24 NAT可以ji连
21:28 交换机一直连  或者 再连一个路由器就可以再分几个口,同时也会生成新的NAT
21:44 光猫
21:49 如何知道自己是否在多层级连?查看能控制的所有设备IP,再看看是否一样
22:09 TCP transmission control ptotocol 控制数据有序到达目的地 对数据进行编号
22:42 TCP常见错误CONNECTION_REFUSED和CONNECTION_TIME_OUT以及CONNECTION_RESET 
22:10 TCP模型
22:50 TCP模型

## 9-13
## TCP
20:01 TCP模型
20:08 TCP为什么确认数据包已收到
20:09 TCP建立连接的本质(面试) 相互交换数据包达成了某种状态
20:12 TCP包头解析
20:30~40 TCP窗口
20:36 滑动窗口
20:44 TCP连接建立的过程,三次握手
20:48 为什么是三次(面试,那几个包头部是什么,重要的那几个)
21:05 信息交换的成功,所以是三次 三条成功的通信,信息交换的公示
21:09 四次
21:17 TCP发送过程
SYN握手包 ACK recet
21:40 push
22:07 四次 此操作可以通过
22:10 四次挥手或者三次的原因(面试) 半开关
22:17 状态图
22:33 tcp不是面向数据包的协议基于字节流的,只能保证数据按照顺序到达目的地
22:36 push有可能上层都不看  粘包拆包(面试)22:38简单解决方式websocket就可以解决以消息为单位发一次接收一次
22:41 队头阻塞 ,对头数据没有收到,就算是后面的收到了也无法交付
22:45 TCP与UDP区别(面试)

## 9-14
## 应用层
20:08 为什么DHCP不需要使用TCP？　不需要传输大量数据
２０：１１　为什么DNS不需要使用TCP？  仅仅是地址解析，不需要传输大量数据
２０：１５  DNS劫持，欺骗
２０：１８  TCP包头为什么是随机数，更好的防止劫持，不是１００％ HTTPS也是防止这个的
２０：２５  NTP
２０：３１  为什么NTP不用TCP，因为有不受调用者控制且调用者不可知的延迟
２０：３２  NTP攻击（已不存在）　DOS，拒绝服务攻击带宽攻击
２０：３６  
２０：３８  FTP连续问答协议
２１：０９　FTP命令格式
２１：１６  被动模式PASV，前面已经验证，只要没有断开就能不需要重新验证
２１：３１  端口监听
２１：１４  ｄｎｓ解析命令
２１：３５  为什么上不了网？　ｐｉｎｇ　－＞　ＤＮＳ　－＞　网关　－＞　目标服务器是否存在
２１：４４  ｎｃ命令，端口可能有问题
２１：４５  １６９.２５４　无法获取IP地址的时候分配的IP
２２：０４  网络安全，为什么相信证书（面试）
２２：１０  加密算法类型
２２：１４  公钥私钥
２２：１８  电子签名
２２：２３  钥匙流程解密
２２：３２  公私选好了就不能改了
２２：３３  证书格式
２２：４１  通过法律证明机构
２２：５０  证书信息实例
２２：５２  TLS握手（面试，看文章）
２２：５４  SSL ｈｔｔｐｓ／ｆｔｐｓ 先建立TLS再继续原有和功能

## 9-15
# HTTP
20:05 二进制协议?开头要重新听听
20:07 http 请求资源,响应资源
20:10 URI/URL都是一种东西
20:15 http一般基于TCp,因为需要传输大量数据 
20:17 不关心什么挥手\握手了,只关心发送和接收
20:28 IPV6如何打端口号[]:
20:30 HTTP发送的协议不一样
21:49 单个域名同时6~8个请求
22:01 解码
22:07 分割请求(面试) 为什么要分割

## 9-16
# HTTP
20:14 浏览器中的绝对地址
20:16 没填地址读出来就是当前界面的地址
20:20 路径部分,查询字符串部分,井号部分
20:22~25 解析URL(面试,用url = new URL('http://www.a.com:8080/foo/bar.html?a=1&b=2#abz') url.searchParams.set('a', 3) //必须是完整链接,js\node.js都可以使用)      ~迭代器是什么?逐一访问集合对象（如数组、链表等）的元素，而不暴露其内部表示~
## XML
20:41 XMLHttpRequst
20:52 request
20:54 AJAX就是下载(面试)
21:01 迅雷(面试)
let xhr =new XMLHttpRequest()
xhr.open('GET','https://class.damiaoedu.com:44313/exam/2',false)
xhr.send()
console.log(xhr.responseText)
21:10 send
21:15 header
21:20 异步  同步发送的话可能会卡住(请求过多) 试一试?
21:28 onload
21:33 回调用法
21:51 XML直接变成DOM  xhr.responseXML
21:58 沙箱
22:03 域
22:11 虽然不能跨域发送求,但是可以自己设置哪些可以跨域
在请求头里面加上 Access-Control-Allow-Origin
(跨域是面试重点)
22:16 只在浏览器有限制
22:19 封装,callback

## 异步
## 9-18
20:14 错误抛给了控制台
20:17 不用promise的抛错
20:16 errocllback 异步放在了里面
20:20 异步调用抛错
20:24 详细解释,已经结束就不会抛出 就是被抛出到了浏览器的代码里面,并没有被捕获
20:30 火焰图解释
20:36 get removeLoading
20:39 try catch的好处
20:47 逻辑清晰
20:59 为什么要写异步,购物车
21:03 jQuery任务队列*(面试) 不能用return,就变成同步了
21:14 jQuery任务队列调用时间
21:19 回调地狱
21:20 jQuery任务队列总结
21:23 300ms
21:30 TaskQueue (面试)
21:48 asyncJS 
21:54 series,串行 undefined是因为本身就没有返回值
21:58 启动时机与结束一致,说明在同时运行 parallel并行
22:20 一单异步就不能通过返回给出结果,只能通过回调给出

## taskqueue promise
## 9-19
20:05 taskqueue
20:11 这不就是迅雷下载吗
20:15 undefind问题
20:18 this由调用方式决定,与调用位置没关系
20:22 next()为undefind的原因
20:26 bind把this绑定在上面  返回一个新的函数,this也就固定了
20:31 箭头函数的this就是构造函数的
20:57 parallelLimit
21:26 map形参解构
21:46 promises
21:56 promises异步操作表达,用回调函数非常灵活
22:03 promises形式 举例
22:08 谁先调用谁是promises的状态
22:17 then  必须异步
22:21 then先于事件绑定
22:25 调用then会产生新的promises
22:28 p2 = p.then(f1,f2) p2的结构由then的返回值决定

## 9-20  
## then
20:10 面试几乎不会出现这道题 |x+y|>2 
20:13 p2 = p.then(f1,f2)
20:15 如果f1或f2运行时抛错了，则p2就失败，原因为抛出的错误
20:23 失败的返回值
20:31 返回值是promise
20:43 失败了怎么办?就取前面的p
21:08 showloading
21:10 catch相当于给then传递第二个参数
21:14 简化调用,但是没什么用处
21:18 同步
21:20 异步递归
21:26 then里面的函数可能是异步的,then是同步的
21:46 specification of promise 与js 的promise不一样
22:07 清空调用?
22:21 Resolvepromise
22:25 get当作属性读取也可能报错(get 报错)
22:27 为什么要读出来then
22:28 防呆

## 9-22
20:04 不能预测链接
20:11 根据数量变化处理
20:15 then返回的不同的情况
20:18 then一定是异步的要用let
20:21 可以变成reduce
20:23 数量不确定的promise串行调用
20:28 promiseall简易解释
20:34 文本的请求用并行(因为不太可能跑满带宽),串行会浪费.虽然服务器确实会变慢,当时是在服务器而不是在网络上进行,不影响速度
20:44 请求时间线(面试)
20:53 并行加载,串行执行 urlCSDN/
21:24 catch的必要
21:26 console为什么要bind,固定this,promise有可能变化 log现在是纯函数可以不bind了
21:31 在promise里面就不需要用其它异步,除非new Promise封装起来
21:48 promise.resolve
21:51 promise.reject  没有处理的话错误会直接到控制台
21:55 promise工场,给then传递promise作为函数传递
21:56 then必须接函数!!!
22:01 为什么promise构造函数是立即执行的
22:06 foo
22:11 与promise有关的函数
22:27 面试实现promise.xxx

## 9-23
20:06 all
20:15 为什么instanceof Promise不可以?因为有其它符合标准的实现 解决用resolve包一层就总会是promise了
20:37 promise any(面试)
20:39 为什么every空返回true some返回false
20:58 finally
21:01 finally不接参数,关心时间但是不关心结果
21:04 手写finally(面试)
21:18 polyfill
21:20 shim
21:25 promise暂时结束..
21:36 HTTP
21:42 RPC remote procedu calls 远程过程调用
22:04 ariaNG
22:15 ariaNG信息解析jsonrpc HTTP封装方式之一
22:25 RESTful/RESTAPI
22:30 HTTp安全
22:31 钥匙验证流程
22:34 虽然公私钥很安全,但是效率太低,一般是先验证好再设置一个密码

## 9-24
20:04 HTTP各种常用头的意思(面试)
20:08 HTTP压缩一般是为了节省流量
20:14 一般是请求头有压缩,请求体小不用压缩
20:18 用逗号分割不同语言比分号强,q是兴趣度
20:24 host  (requ)
20:29 referer 有隐私泄露可能referrer 可以设置referrer-Policy 不发送完整url到referer头中 (requ)
20:37 content-type:image/jpeg 常见文件格式类型  (resp)
20:40 date (resp)
20:42 Content-Length (resp)(requ)
20:43 transfer-encoding:chunked 不知道body有多长
20:56 last-modified (requ)
20"59 if-modified-since (requ)
21:03 ETag:hashcode (resp)if-None-Match:hashcode  (requ)
21:09 expires
21:11 一大片不连续单词不是常用头
21:13 user-agent 现在只有大版本号 (requ)
21:15 浏览器指纹
21:19 server 服务器(resp)
21:22 防盗链(面试) 不能反爬虫
21:27 referrer Policy
21:30 content-security-policy
21:34 iframe祖先

21:52 cache-control 控制缓存,相对复杂,有rfc文档 为什么用不到?体量小,除非(直播)
21:58 connection:keep-alive
22:03 cors相关头  跨域请求
22:06 为什么简单请求不发送预检请求
22:12 预检请求流程
22:14 预检请求不能带自定义请求,除了规定的那几个
22:20 预检请求模型

##  异步yeid
## 9-25
20:08 生成器函数运行回顾
20:09 yeid return
20"10 yeid throw 右边抛出错误左边没有赋值成功
20:14 生成器函数与结合promise结合
20:18 yeid如何拿到promise的value值
20:20 接住yeid的next()
20:23 接住yeid的next()的流程
21:11 没有try回到哪里捕获 从谁调用yied
21:16 抛出错误就可以失败了,reject
21:19 最终的co函数
21:33 协程 coroutine 不是真正的多线程
21:46 async function
21:51 为何async要会promise
21:55 async function *
22:04 for await of 专门用来迭代异步生成器
22:09 await在控制台可以直接使用

## 9-26
20:03 async在ES2017之前怎么用的(面试)
20:10 面试题
20:18 面试,yield之前的写法regeneratorRuntime
20:36 不能用let怎么办
20:51 pizza
21:09 安排不同效率不一样  合理安排异步的时间
21:36 模块
21:48 多打几个断点可以很清楚看
21:58 重用
22:17 供应商投毒

## 9-27
20:00 调用import
20:08 解耦
20:12 版本号  主要版本号.功能.补丁
20:22 在线编辑器
20:25 命名空间
20:30 IIFE立即执行函数表达式
20:33 中气十足的(面试)
20:36 函数语句
20:58 () => {} 不能在后面加括号
21:01 (() => {})立即执行箭头函数21:07 exports导出模块写法
21:14 模块系统
21:24 模块的一些引用区别
21:47 js的模块系统  es module语法
21:55 导入
22:00 在html使用 但是不能在文件网址发生,可以使用http-server来调用该文件
22:17 动态导入
22:27 importmap

## 9-28
21:00 浏览器缓存问题
21:10 
21:14 lexcial 但是eval可以读到
21:23 字符串当作代码执行  eval ,new Function, dom ,settimeout
21:26 require
21"38 exports
21:56 reuqire3
22:05 reuqire4
22:07 模块导出单个的时候

## 9-29
20:02 懒加载
20:12 本机上跑大概3ms以内(除非电脑硬盘都很差),但是网络上跑就不一定了,所以不能串行
20:17 同步require不能接收的原因 
20:23 异步require
20:27 保存到映射(非常重要)
21:28 构建对象解决
21:42 打包
21:55 打包
21:59 即将webpack
22:17 模块相互依赖是可能存在的
22:19 循环依赖解决(面试,不一定会问)

## 9-30
20:02 接口
20:08 遇到ugly接口封装它,变得更好用
20:30 适配器
20:37 分层设计接口
20:40 邮件接口
21:03 lodash 
21:13 cloneDeep(面试 需要一个映射)
21:37 matchesProperty
21:42 matches
22:10 bind

## 10-3
20:04 todo
20:07 无论写的多垃圾,要把基本的UI写出来
20:15 除了丢弃的API,其它都可用
20:18 除非很简单的界面,不要用onclick
21:01 刷新还在的功能
21:06 以数据为中心写todo ?前面的
21;19 添加事件(因为会冒泡
22:00 VUE
22:16 双向绑定
22:20 全局event

## 10-4
20:14 vue2/3
20:21 渐进式框架
20:24 UI/UX UI现在一般包含视觉和交互效果
20:26 选项式API
20:36 响应式 命令式
20:59 vue基础
21:09 危险的写法
21:11 浏览器中的script,遇到第一个/script就会结束(加上反斜杠即可)
21:16通过innerHTML给dom插入的script/style标签在现代浏览器
是不会执行的,会有安全问题 textContent会,但还是非常危险
21:24 v-bind
21:28 函数最好写在method
21:31 只有一些全局变量能用,还是写在data里面较好
21:40 指令
21:47 响应式基础
21:50 为什么添加不了 ,最好直接在return上加
现在可以直接调用了(vue2get set,vue3 proxy)
22:07 proxy 与 get set
22:14 DOM更新并不是同步的(因为异步调用)
22:20 不是同步的解释 setTimeout Promise
22:25 有状态的方法

## 10-5
20:03 computed
20:27 为什么不会变data.now() 因为没有被调用没有被监控
20:29 简单演示 依赖搜集原则
20:34 重新更新?
20:36 赋值 几乎用不到
20:40 能算出来就不用重新写一份
20:43 class类名绑定
20:49 ['a','b',cc,dd]
21:07 条件渲染
21:09 v-if v-else 必须相邻
21:11 template 一般同时出现多个元素才使用 v-if
21:16 template不会出现在DOM中,是html5新增的
21:17 为什么v-if v-for不要一块用
21:23 vue2 forif vue3 iffor 用在同一个元素中时
21:32 dl dt dd template
21:35 数组变化侦测
21:38 直接通过数组下标修改 不是get set修改感知不到
21:39 数组下标有可能很长不需要改成getset
21:42 但是一旦更新界面就能看到 比如push,都被更新了(因为并不是数组原生的push方法,被劫持了,vue自己提供的)
21:50 面试 vue2 与vue3 数组的下标
22:02 事件处理
22:11 方法与内联 编译器
22:16 修饰符
22:23 表单输入绑定
22:33 选择器/下拉框
22:39 v-model修饰符

## 10-6
20:02 生命周期 重要 vue2
20:05 git里的hook
20:11 生命周期图形讲解
20:15 this是会被初始化为事件监听器
20:22 ?\
20:23 vue3里面的this初始化
20:26 预编译模板 很重要
20:28 虚拟DOM如何编译的
20:38 DOM即使在读取的时候也比普通js对象慢
20:41 极简创建DOM tag:name 也叫虚拟DOM 只保存必要信息,并不是真正虚拟 
20:47 都是虚拟DOM对比(表达的信息量差不多),然后再到真实DOM里面去增加
20:48 这就是为什么能做到需要改变的地方
21:05 Vue.compile
21:09 _render() 虚拟DOM节点
21:12 使用完整版vue2 Vnode 
21:14 app._render() === app._vnode false
21:19 证明compile编译的就是app.$options.render 
21:27  实际上不是对比的真实DOM而是VDOM 
21:31 patch对比
21:33 prevVnode 记录的是html的最外层的app 更新 app.$el 与 $0(app)._vue_ 的关系 
22:06 watch
22:08 watch深层监听器
22:19 onWatcherCleanup 清理因为变换过快导致的监听器副作用
22"22 fetch 返回的是promise
22:27 controller.abort 中途取消fetch
22:30 因为signal上监听abort事件 执行取消操作，清理产生的副作用，清理空间占用等
22:32 取消控制器 面试
22:35 sync 变更前取消回调abort sync 变更后取消回调abort
22:37 命令式取消

## 10-7
20:01 模板引用
20:03 为什么有时候光标不会focus,因为要渲染
20:13 挂在mounted可以持续focus
20:14 ref 变量指向值 对某个东西的指向
20:24 ref写在循环上会指向数组
20:32 ref变量,一般是对象
20:35 btn
20:59 模板可以直接写在vue实例的template里会直接替换
21:03 组件
21:09 product-card id
21:12 product-list
21:14 wbe components 一直在进化,不会用,了解即可
21;18 shadow DOM
21:26 查看元素内部结构 showshadowDOM 在控制台里面打开
21:29 vue框架里面的组件
21:34 elementPlus
21:48 ant design
22:01 封装的两个角度
22:07 vue3框架里面的组件
22:12 component
22:28 各种属性的叫法 attribute property props 小本本
22:32 组件版轮播图
22:36 为什么图片写在里面 作用域问题

## 10-8
20:04 谁的模板用谁的数据
20:36 资源分配与释放 指针指向的空间
21:07 key面试
21:17 对比两个vnode结点的大致算法
21:31 :key对比  面试高频
21:38 key对比 遇到组件的时候
21:44 轮播图组件更新
21:58
22:12 模板引用
22:18 组件注册 一般都<ComponentA/>这样写 但是写在浏览器的html里面就用全小写
22:23 局部注册
22:26 组件名称
22:27 props
22:29 动态props
22:31 单向绑定
22:32 组件传递
22:37 数组,对象props绑定是探测不到的,仍然可以更改
对象或数组内部的值。这是因为JavaScript的对象和数组是按引用传递
22:42 props校验

## 10-9
20:02 Tab标签组件
20:22 this指向了window没有在组件里面 变成函数也不确定
20:30 不能再组件中直接this.xxx 因为这个this指向的是Windows,除非放在函数里面,但是也要看是否是作为方法调用 作为函数调用依然不可以 
20"34 解决方法,写成get,不过最好还是不要这样写 (面试)
20:36 使用var的时候 var obj = undefined 
20:37 TDZ Temper Dead Zone
20:40 事件
20:45 vedio
20:51 $emit自定义事件
20:11 没有冒泡机制
21:14 可以传多个参数
21:16 声明触发事件TS 
21:24 组件v-model基本用法 (面试一定)
21:31 组件v-model实例
21:41 坑点 为什么组件v-model绑定input后输入不了(有可能面试) 外层刷新连带着内层刷新 21:48 解决方法,添加watch
22:11 v-model参数
22:13 多个双向绑定
22:14 v-model修饰符
22:20 透传Attribute
22:27 props与Attribute的透传 想要不透传可以禁用
22:31 多根节点Attribute
22:36 可以使用v-bind一起传递
22:40 异步组件 组件是模块 模块不一定是组件
22:48 defineAsyncComponent 请求异步组件

## 10-10
20:11 组件接收数据不要修改
20:16 vue3会删除一行前后空白,vue2不会
20:22 为什么没有运行 二维数组
21:00 插槽
21:06 slot
21:27 定制插槽
条件插槽
21:39 动态插槽一般用不上
21:42 作用域插槽,一般工作中也不会写
22:14 无渲染组件
22:20  依赖注入
22:28 注入

## 10-11
20:02 组合式函数
20:13 onMouseMove解绑方式
20:17 组合优化 mixins
20:30 mixin存在的问题
20:37 组合式函数mixin 
20:51 如何实现这个函数本次在哪里调用
21:12 setup()中onMounted源码运行机制
21:24 hook ract面试常问
21:30 js不能监控变量的变化 面试
21:58 组合式函数API
22:08 ref 解包 绑定值和对象的value
22:12 ref 数组,map不会解包
22:15 watch只能监控函数\ref\obj\array
22:19 依赖 ref 与 computer是相互依赖的 惰性
22:34 watchEffect() 懒执行
22:53 expose

## 10-12
20:26 setup轮播图
21:09 setup的函数用法
21:15 e4x
21:17 jsx 只是一笔带过没细说
21:18 toVaule
21:20 toRefs
21:22 isProxy
21:23 shallowRef 浅
21:25 customRef
21:27 track trigger
21:30 shallowReactive
21:31 shallowReadonly
21:31 toRaw
21:33 effectScope
21:37 getCurrentScope
21:38 onScopeDispose
21:44 依赖注入
22:03 为什么onMounted放入一个函数后能知道在哪一个组件 可能的面试题
22:14 use 其它名字也可以
22:22 组合式USE函数总结
22:31 组合式函数名称的由来
22:33 VueUSE
22:50 Vue 组合式函数文档

## 10-13
20:02 use的新解释
20:09 caller可以知道被谁调用 知道被谁调用
20:24 expose
20:30 其它杂项选项
20:30 name
20:34 组件实例
20:40 自定义指令
20:48 可以编辑的todospan
20:53 指令沟子
21:10 插件
21:12 内置组件
21:13 KeepAlive 状态的切换
21:22 异步依赖 setup
21:34 errorCapture组件错误抛出机制(类似)
21:39 进阶主题 Web Commponent
21:42 为什么要使用组合式API 面试
21:46 深入响应式 什么是响应式?
21:47 响应式如何工作的
21:49 单层对象代理写法?
22:09 track trigger
22:12 运行时响应与编译时响应
22:22 响应调试
22:22 信号signal
22:24 渲染管线
22:27 template比render渲染的性能更高
22:35 vue2 vue3的重要区别 面试
22:51 带编译的虚拟DOM 
22:54 渲染函数与JSX 不用管 

## 10-14
20:32 最好不要修改传入的数组,最好是谁的数据谁能改
20:35 下层组件与上层组件通信
20:37 相邻组件下层给上层传递,使用事件对象
20:38 组件之间传递信息
20:50 因为最好不要修改不是自己的数据,不能v-model = todo.complete 但是太多就不写了
20:58 为何不写?除非应用整个业务逻辑
21:02 通用组件最好别打破
21:06 自己的业务逻辑分布在多个组件中,就用全局的data
21:13 直接从服务器拉数据,一般不会用缓存(app有时会)
21:24 一份数据全都用  Pinia
21:29 Pinia实例 响应式
21:33 自定义组件在DOM 里面不能自闭合
21:37 单文件组件
21:47 props只在开发时候判断类型 少去了判断代码(模板编译器) 所以体积小 prod.js
21:52 开发环境与生产环境
21:58 runtime 仅包含运行时与编译时(少去了模板编译器)
22:00 每个版本的区别 面试
22:02 bundler
22:04 require import等用哪些版本
22:05 为什么要使用单文件组件
22:07 HMR
22:09 单文件如何工作
22:14 项目脚手架 Vite
22:18 winpty 部署
22:32 script setup export default
22:41 组件注册 ?
22:58 现代vue开发和问题
22:59 如何接props
23:07 如果用了“需要感知自己在哪个组件内”的组合式函数，则必须写在第一个await之前(在一般setup中)
23:08 因为这些函数必须同步调用才能感知到自己在哪里 的解释 有可能面试(在一般setup中)
23:11 顶层await
23:13 use辅助API
23:15 useID

20:04 为什么script setup 的需要知道自己在哪里的函数可以写到awiat前后都可以?
20:16 void运算符
20:17 框架要看编译结果才知道在怎样走
20:25 英语的妙用
20:26 nmp配置国内源
20:44 pinia部署运行流程
20:45 组件需要的依赖
21:06 pinia
21:08 state的两种写法
21:36 什么时候放在store里面 最好不要存储临时状态 应用可以,网页不行 因为网页一般都在有网络情况下打开都能访问最新数据
21:44 state
21:52 getter
22:20 storeToRefs 保持响应性
22:22 mapState
22:25 双向绑定 为什么会解构呢?
22:31 mapState极简实现 可能的面试题
22:35 可能的面试题
22:38 Action

## 10-17
20:03 单文件todo
20:08 clearCompleted 的todo 使用ref与react的不同
20:39 css添加
20:42 删除按钮全新写法
20:49 21:07 tailwind配置
21:11 router路由
21:16 界面并没有刷新
21:18 大致的路由router写法
21:27 路由模型 地址的不同看的页面不同
21:33 SPA single page app
21:36 安装路由
21:40 router渲染过程
21:44 views 可复用页面组件
21:47 入门
21:49 memoryhistroy createWebhistory 
21:54 createWebHashHistory
21:55 22:00 vite极简工作原理 面试 会转换成能被浏览器运行的js
22:19 vite关键原理 不打包,直接在浏览器运行js
22:20 createWebHashHistory是将页面放在/#/后面
22:29 vite 可以配置baseurl
22:37 createWebhistory 应用入口
22:43 22:49入门访问当前路由$router $route
22:55 params 不知道里面是什么log出来看看
22:58 动态路由
23:02 捕获所有路由或者404 路由
23:07 嵌套路由

## 10-18
20:05 微信简易界面
20:13 =>import 异步模块还没有运行节省流量
20:26 实现整个界面朋友圈
20:40 文档没有说的路径写法
20:48 编程式导航
21:05 命名路由
21:08 location assign replace
21:12 编程式导航
21:16 router.go
21:18 命名视图
21:21 嵌套命名视图
21:25 重定向
21:28 别名 alias
21:31 props 路由组件传参
21:43 RouterView
21:44 匹配当前路由器链接
22:10 不同历史记录模式的区别
22:21 推荐使用memory 模式
22:23 导航守卫
22:24 befoeEach
22:26 全局解析守卫
22:27 路由更新时机
22:28 数据获取
22:34 组合式API
22:34 useLink 自定义标签
22:39 RouterView插槽
22:43 transation做动画的时机
22:47 滚动行为
22:52扩展RouterLink
22:56 导航故障
22:57 动态路由

## 10-19
20:02 TypeScript
20:04 变量
20:06 静态类型与动态类型 强,弱类型
20:17 静态类型的好处
20:34 开始TS介绍
20:39 js的运行
20:41 静态类型检查
20:42 Non-exceptionFailures
20:50 types for tooling
21:00 tsc
21:04 Explicit Types
21:06 Date() new Date() 是不一样的
21:09 什么时候写类型声明
21:11 Erased Types
21:13 Downleveling
21:15 Everyday Types
21:20 静态语言里的数组类型 Arrays
21:23 any 可以使用noImplicitAny禁止
21:30 函数返回值类型
21:32 Promise的返回方式
21:35 Contextual··typing·for·function 一般不能在后续使用反向推到之前变量的类型
21:37 Object Types
21:40 Object Types 可选属性
21:44 Union Types 联合类型
21:50 类型别名 Type Aliases
21:53 interfacePoint 接口声明类型 
21:55 type跟interface有什么区别 ts面试 type可以直接声明联合类型
22:08 Interfaces
22:12 Interfaces的添加与扩充
22:14 八股面试TS Interfaces不能起别名
22:18 TypeAssertions
22:21 as类型提示
22:26 面试 as只能向类型更大转或者更小转
22:29 Literal Types 直接量类型
22:30 类型值的集合 小本本
22:33 alignment 常量联合类型 一般用于多个值 限定填写哪一个 ?
22:37 Literal Inference
22:43 将整个对象转换为类型
22:45 null and undefined 可以开关
22:47 x! x一定不为null
22:49 bigint
22:49 symbol
22:50 typeof 在js ts是不一样的 

## 10-20
20:21 Narrowing
20:26 type guard 类型守卫
20:31 Truthiness narrowing 根据真假收窄
20:35 Equality narrowing 相同收窄 ===
20:39 in 运算符 :() => 描述函数类型
20:41 instanceof narrowing
20:42 Assignment 重新赋值之前类型不会改变 await似乎检查不出来
20:46 Control flow analysis
能判断if流else不同的值的属性 控制流分析
20:48 Using type predicates isExtensionable
20:57 Discriminated unions
21:02 TS非空提示符
21:08 freshness 新创建的对象必须对应指定接口
21:22 never type 一般用来提示类型的增加
21:23 Exhaustiveness checking
21:27 function Type 函数类型标注 (a:string) => void
21:33 调用签名 Call Signatures
21:36 当对象是函数的时候写法不一样
21:39 没有缩进的提示可能会感到眩晕
21:43 Construct Signatures
21:44 泛形Generic 面试高频
21:54 模板类型 <T,U,V> 可以接多个
22:11 never类型空集
22:28 为什么是never类型空集 never是更好的选择
22:34 any unknown never 的区分
任何类型都可以赋给any
unknown可以赋给任何类型（加个as之后）
22:36 输入与输出类型
22:38 Constraint extends继承类型
22:43 47 常见错误 return{length:·nminimum} 可以传入,但是不能直接返回
22;52 直接写类型与extend类型不一样 extend不能反向推断是什么类型,再返回之前已经被推断
22:59 类型参数 有多个地方是同于一个类型,但是类型不去确定
23:02 函数重载Function Overloads
23:07 TS如何写重载
23:11 ?表达式不能作为属性赋予 因为是一个可以改的变量 解决:直接声明类型即可
23:15 this在函数的时候 DeclaringthisinaFunction
23:17 Other Types to Know About (void,object,unknown,never,Function)
23:21 Object type object 可能会不一样 最好只用大写Object
23:23 不能对unknown做任何事情
23:25 never
23:35 Function 只代表有这些bind\call\apply 不如用()=>void运算符
23:27 Parameter Destructuring 解构类型 参数解构

## 10-21
20:01 AssignabilityofFunctions
20:05 不关心返回值的函数void,可以赋给他一个有返回值的函数 return type void
20:09 forEach
20:12 //@ts-expect-error不会报错
20:14 属性修饰符 PropertyNModifiers
20:18 let {a:A,b:B}=obj let A = obj.a let B = obj.b 被JS占用的语法
20:19 readonly 只读 可以通过不是只读的来修改
20:21 object.seal
20:24 Index Signatures [index:number]:number|string unknown(任何属性)
20:23 ExcessProperty Checks 不能只给unknown加属性
20:35 新对象就是不能加属性
20:43 Extending Types
20:45 Intersection Types
21:03 接口继承与扩展的区别
21:06 并集,交集
21:08 泛形 interface 面试 什么支持泛形 小本本
21:16 嵌套 泛形 interface
21:21 类型体操 Generic Object tTypes
21:28 Array<type> 数组专属语法
21:33 class 泛形
21:40 Promise<number>
21:45 Tuple type 长度固定的不可变数组 元组类型
22:02 Creating Types from Types 一个类型生成另一个类型
22:05 keyof
22:17 keyof限定类型 function getProperty<Type,Key extends keyof Type>(obj: Type, key: Key){return obj[key] }
22::23 create
22:25 class type
22:33 泛形参数的默认值
22:35 in out
22:42 类型运算符 Thetype of type operaton
22:45 returntype 面试
22:47 Indexed Access Types

## 10-22
20:06 extend可以作为类型约束或类型比较
20:07 Conditional Types 三个重载例子xx extend xx ? xx : xx
20:16 单类型不能直接分配联合类型
20:20 因为类型窄话带来的改变
20:27 联合类型的extend继承 T extend number|string 是右边所有联合类型组成的集合的任意子集组成的联合类型
20:30 never是由一个原本由类型组成的集合在空集时的状态
20:35 Conditional TypeeConstraints条件类型的限制
type·MessageOf<T·extends·{·message:·unknown·}> = T["message"] 若不能确定T有没有message需要这样写
20:47 传入一个promise的类型，返回promise内部包裹的类型 可以简化为infer 可能会面试
20:55 infer的具体含义 
infer的意思是，如果传入T类型能让inferU位置填入某种类型后让条件判断成立.那么请把应该填入inferU位置的类型赋值给u类型，然后该类型可以问号右边使用.
21:00 ...args: infer
21:13 infer可以有多个 ~21:29
21:16 函数可以继承函数的类型
21:22 如何使函数的参数类型匹配传来的任何一个函数
21:25 函数\对象\参数\联合类型中不同的extends
21:28 容易混淆的参数extends匹配
21:32 容易混淆的函数extends匹配
21:35 对于函数的A·extends·B来说
满足A类型约束的函数一定可以以B类型的约束来调用工这种时候extends才成立 
对于参数来说,A的参数类型可以比B的参数类型丰富,对于返回值来说,B的返回值类型可以比A的返回值类型丰富. 小本本
21:38 ReturnType 面试手搓
21:39 Distributive ConditionalI Types
21:41 传入的联合类型作为整体来处理
21:42 Mapped Types
21:49 -readonly -?
21:54 Key Remapping via as
21:56 ` ` 反引号里面的类型是有限制的
22:01 infer字符串分割
22:21 手搓去出一个值的属性
22:32 Further Exploration
22:33 模板常量类型处理字符串 Type Manipulation
22:45 class不怎么用
22:53 pick
22:56 Myomit
23:00 NonNullable

## 10-23
20:02 promise手搓TS
20:27~21:02 on方法,TemplateLiteralTypes ??
21:02 react
21:09 babel是JS语言编译器,把新版本的js编译到旧版本运行
21:11 ract会编译一些JXS和elt
21:23 Vue在不同ES环境下怎样调用
21:26 react里面是没有类型标识的,用一个朴素对象保存
21:33 内置组件加引号,外置不加引号 传递组件的函数,而不是名字
哪一个编译更快??21:37
21:37 react与reactDOM的区别 面试21:47 react之所以有两个包是因为react用于创建和管理react组件,但是不负责渲染他.reactDOM用于将组件渲染到DOM.ReactNative,可以将react组件用操作系统原生（native)ui渲染，以达到更高的性能.vue叫veex但是没怎么用
ReactCanvas(非官方).ReactConsole(非官方).
21:56 不同组件跨端开发的好处
22:02 uni-app
22:16 组件库可能是不一样的,定义新标准,最终渲染是一样的 面试
22:21 react link
22:23 react的两种写法 fuction class(比较少用)
22:23 react class
22:31 jsx都是表达式
22:34 一般jsx要打括号
22:35 逗号表达式(1,1)返回最后一个
22:38 jsx用逗号的注意事项 <div></div>
22:42 jsx {}模板
22:47 函数取出来后就与之前的上下文脱离关系 react this 在调取函数时候无法确定this是谁需要bind
22:54 push的返回值是数组长度
23:01 react map数组的使用

## 10-24
20:03 为什么要bind绑定 ~20:10
20:06 或者写成箭头函数
20:10 bind,箭头可能浪费空间
20;13 可以存储到构造函数里面去,不用每一次都创建
20:16 或者在构造函数里接收一个箭头函数 = () => {} 然后写到外面20:20
20:18 class字段复习 fields #p 私有
20:26 为什么这里的foo需要bind ??
20:43 createClass 挖坟的用法
21:02 todo
21:04 htmlFor 是for class是classname
21:07 ul里面多个li写上多个数组{map}
21:14 onchange为什么需要添加 最重要的是保持UI与数据是一致的
21:20 非受控组件 checked
21:28 改数据必须通过setState
21:33 forceUpdate() 强制更新
21:39 不能修改原始对象!!!
21:46 如何文本插值实现v-if
21:50 error boundary
22:07 写defaultValue是不会受到没有change无法编辑的影响
22:15 visible-type
22:21 clsx
22:24 parent state
22:26 用tailwind group写ul的classname并隐藏li
22:34 太大直接写在DOM
22:37 即使添加也不能修改任何原始值
22:38 编辑功能 onDoubleClick
22:49 autoFocus 自动获取焦点,不用再点击一下

## 10-25
20:02 class组件的剩余部分
20:11 编译结果造成的_this,就是给this换了个名字 ~20:15 而且是必须要在运行过程中才会这样,运行完成后会变回this
20:15 如果是inc()这样声明而不是这样inc=()=> this不会改变名称
20:17 sourceMappingURL 编译后代码与源码之间的关系 面试20:17~27 放在head的sourceMappingURL里面
20:19 什么是token?程序里面拆开没有含义的词语
20:21 任何一个文件可以直接转换为dataUrl,记录源代码的所有内容,源代码与目标代码的关系   解析
20:24 mappings映射,name对应源代码的哪一个名字
20:25 sourcemap
20:27 可以通过调试来隐藏dataurl 代码太多了
20:31 面试参考的一些关于sourcemap的问题
20:36 babel的一些使用指南
20:40 babel如何做到编译代码
20:42 一组babel插件的集合presets
20:44 babel data-presets的使用 env判断当前环境认识的语法(也可以指定版本) react 相当于设置需要编译的东西
20:48 stage
21:04 setState的运行逻辑
21:09 assign
21:16 setState其实会重新存储一个
21:20 setState不能假定它是同步还是异步
21:25~21:3 setState(state =>{}) setState(state =>{})
两个什么时候异步调用(可以累加),什么时候修改状态
21:45 setState里面会有一个实行异步的函数
21:46 调用栈里面出现一些粗体表示存在调用栈清空 异步
21:50 证明之前版本中也是异步操作 但是旧版本queMic没有
21:56 旧版本react的setState是同步更新的
21:57~22:20 如何回答setState的面试问题? 同步还是异步(16有时候同步有时候异步同步会立即合并并立即更新dom;最新18始终异步)?什么时候同步什么时候异步?setState做了什么? 小本本
22:21 react类组件的生命周期
22:25 生命周期图
22:30 无法在jsx渲染滚动条
22:33 static getDerivedStateFromProps 静态类,不在链上
22:35 与直接写在this.state上面的区别 如果更新后不需要状态就可以写到getDerivedStateFromProps里面,二者在使用的时候会合起来 似乎有错误这种说法
22:39 那些情况下需要更新后不需要状态 输入框
22:43 过时的生命周期方法 因为不安全会造成bug

## 10-26
20:03 生命周期继续 如果外层使内层更新会调用should ??前
20:05 不写构造函数的class生成方式 
20:11 标签之间的属性都是children
20:14 shouldComponentUpdate
20:24 preact轻量化react
20:25 函数组件 funcion component
20:27 函数组件的一些特征完全去this
20:39 vue3 和 react都忽略前后的空白
20:41 JSX将对象属性传给一个元素
20:49 函数组件也叫无状态组件
21:05 函数组件添加状态
21:13~21:32 useState的运行过程
21:17 会把set改变的存储在useState的内部由react自己维护每一个组建的状态
21:22 名字相同的组件状态也是不同的
21:24 useState(Hook)简要运行逻辑,运行会检查状态,检查运行一次,更新运行一次
21:28 能感知到在哪一个里面调用
21:36 useState并不知道状态是干什么的只知道值
21:41 useState知道自己为哪一个组件运行也知道组件函数里面调用的顺序
21:45 组件之外调用(比如控制台)会出错
21:48 或者在同一个组件实例调用顺序,次数改变会出错 面试必问 为什么react hook函数不能改变调用顺序
21:53 useState 必须对应顺序
22:03 调试hook
22:08 useState(()=>2)的区别useState({a:1,b:2})对象较大节省空间
22:13~22:18 hook函数不能改变调用顺序的错误归因,与存储的方法(数组,链表)无关,只是跟调用顺序有关 面试 小本本 
22:19 面试小窍门
22:20 hook的调试(需要首次挂载运行)
22:35 fiberNode就是记录了组件的状态 16.7之前是没有的

## 10-27
20:04 传统函数与react hooks函数(useState)的区别 小本本
20:10 什么是否函数会用到全局变量  记录函数自己调用了几次 记录递归层次
20:13~20:46 react-hook函数api模拟
20:46 再次证明与背后怎么存储没有关系
21:00 useState的调用声明不能写到if或者for里面
21:01 function轮播图
21:07 在set外修改变量i , 会重新生成一个作用域,但是最好不要修改
21:26 useState的set函数在18版本中都是异步的 面试
21:33 js的label 为代码起名字 小本本
21:36 label一般用来标注循环的名字
21:42 consle.dir 作用域链查看
21:45 setI(i => i+1) setI(i+1) 基本是一样的但是setI(i => i+1)的i+1访问的是箭头函数的i
22:00 react闭包陷阱,useCallback包一层
22:23 如何在按钮不变的情况下不更新 class 的shouldComponentUpdate
22:28 函数组件如何实现 在按钮不变的情况下不更新
22:31 memo 被React。memo包裹的组件，如果新传入的props没有发生变化则不更新组件
22:35 PureComponent纯组件方法
22;40 给组件取名字的好处,不然不好debugger 也可以displayname设置名字
22:50 只要不是卡的不能用无脑写就ok

## 10-28
20:02 react其它常用hooks函数
20:05 函数组件根本就没有生命周期,但是可以近乎完美的模仿出来
20:07 memo就相当于shouldComponentUpdate
20:14 不需要 static
20:19 很少在组件函数里面调用useState set调用props修改状态
20:23 useState里面的值只会用一次
20:32 函数组件需要的生命周期图
20:34 deps 昨天也有提到
20:35 useEffect 只会在组件挂载和依赖项变化时执行，从而避免了无限重渲染的问题。
20:38 useEffect的运行示意图
20:40 useEffect闭包陷阱
20:44 清除useEffect副作用
20:46 如果给deps传递了函数会清除副作用
20:48~20:51 useEffect生命周期模拟 deps给值就是更新 正好负载了三个生命周期
21:03 给deps加上props即可更新
21:05~21:12 useEffect生命周期模拟
21:12 setTimeout 与 setInterval
21:17 一般都要把props写到[]里面
21:16 可以写多个useEffect精确更新
21:18 轮播图运作时间线
21:21 手写自动播放轮播图
21:31 一加载就在检测到鼠标在轮播图里，停止自动播放
21:37 react ref 存储指向的元素 
21:40 能够查询变量更改的语言的原理\
21:45 js如何解决的查询变量更改{value:1}
21:47 currnt此时此刻指向谁
21:50 需要使用useRef() 使得ref在生命周期内指向同一个对象
21:53 current的使用
22:04 验证ref在vue是一样用的,但是vue里面不能用:
22:10 面试问到ref怎么答 小本本 不同位置共享数据
22:13 给标签添加ref属性指向(字符串ref),class里面可以用,但是不推荐
22:14 为什么不推荐使用字符串ref 面试 小本本
22:15 太复杂
22:19 再次样式为什么复杂 因为需要创建真实jsx元素
22:23 为什么对象,函数ref更简单
字符串:ref="xxx" 函数,ref{(el)=>this.foo=el},传入ref对象:ref={obj}
2227 class使用对象,函数ref
22:31 为什么class可以接ref,函数不可以 面试 小本本
22:34 函数不可以接字符串ref 
22:39 class里面creatRef不会更新,因为是在this上修改没有通过setState 小本本
22:42 函数组件在哪里存储ref
22:43 为什么以var变量生成全局ref只能用一次 更新后是上一次的ref
22:48 useRef新旧作用域指向的ref都是同一个
22:56 hover不更新?? ref可以放在不变的地方

## 10-30
20:02 轮播图部分ref状态
20:19 不需要给函数组件写ref,给class组件写ref指向的是new出来的对象
20:33 react的hook函数为什么不能更换顺序或者放到if里？vue的hook函数为什么不能更换顺序或者放到if里？(因为setup只运行一次) 小本本
20:35 其它常用hook函数2
20:36 useMemo 一般用来计算
20:39 useMemo运行图 ref也可以写在deps里面
20:42 usecallback等价useMemo的写法 小本本
20:47 useID
21:10 useReducer
21:22 useReducer运行图
21:29 useInsertionEffect
21:29 useLayoutEffect 
21:32~21:40 浏览器什么时候重绘 promise,queue安排的回调(MicTask)在运行之前浏览器是不会有其它操作的 但是setTimeout是会渲染的 
21:42~21:46 useLayoutEffect 触发时机 重绘浏览器之前调用 面试
21:50 重绘的回调时机 postMessage单词之前双次之后就 小本本
22:07 不可预知宽度组件
22:07~22:14 useEffect useLayoutEffect 触发时机
22:14 useInsertionEffect什么时候触发
22:17 css-vs-scc-in-js 很丑 22:18 jss 22:20 一些其他的css-in-js方案 这些都是tailwind之前的方案
22:23 直接用tailwind即可
22:31 useImperativeHandle 指令式
22:29 虽然函数组件不需要ref,但是在实现一些需要focus的场景,可以用props暴露出去22:32~22:35
22:37 useImperativeHandle运行逻辑 避免每一次都运行
22:41 useImperativeHandle手动实现
22:43 命令式 指令式 的区别
22:44 ref当作props传递是空的
22:45 设计失误
22:46 forwardRef
22:48 forwardRef返回的组件是一个专门用来转发ref的组件，所以叫forward（转发）ref
22:51 react19删除了forwardRef,所有函数组件自动拥有转发ref的能力

## 10-31
20:03 hook函数继续
20:04 useContext 解决数据的跨组件层级传递机制 小本本
20:09 上下文机制
20:10 jsbin讲解
20:15~21:26 Context实现React.creatContext()
20:17 ProVider Consumer(现在不怎么用了)
20:19 ProVider value
20:20 useContext用法
20:22~45 传递两个以上不同的值,套两个ProVider(挨在一起),useContext 更新机制
20:26 可以value接setState来改变状态
20:30 量子纠缠更新
20:33~22:40 验证中间一个组件即使不更新,也能跨越这个不更新的组件传递下去(memo) 以及组件不更新,并且嵌套的组件也不更新那么就都不会更新
20:38:~20:42 为什么永远不要修改旧对象,传入新对象 因为程序不会检查变量是否改变
20:45~20:51 Context更新机制2 .Consumer方式也可以嵌套多个组件
21:05 组件返回函数 
21:10~21:14 解决类组件使用Context更新机制2的丑陋问题 声明一个静态属性 但是不能写成数字,因此只能存储一个
21:10 provider可以在class组件使用
21:12 给class声明一个静态属性static 就会传递到this.Context
21:16 Context 三种用法 小本本
21:22 react组件库 Ant Design
21:26~39 自定义hooks 根据现有的hooks组合成一个新的hooks,一般都要复用 面试高频
21:30 object不能放里面{},需要toStrong 
21:35 自定义hook的使用
21:42~21:47 类似双向绑定
21:43 受控组件没传参就是非受控的
21:44 受控组件非受控组件 react官方文档里面有
21:47 useVModel setModel简易双向绑定 只能在函数组件使用
21;52 自定义hook返回的函数尽量不要变,免于更新 
22:04 其它自定义hook
22:05 ahooks
22:05 useRequest
22:14 useRequest轮询
22:17 useRequest依赖刷新
22:18 useCountDown 面试
22:37~22:45 为什么组件的事件与系统不一样以及解决
22:49 lifeCycle
22:52 useSet 为什么不能useState对象
22:58 useInterval useForceUpdate useToggle容易面试

## 11-1
面试可能写这些
20:23 useForceUpdate()
20:27 写自定义hook时的要点 最好返回固定函数
20:30 useCounter
20:51 useSet
21:10 useInterval 超高频面试
21:08 useInterval面试的要点 ref避免闭包陷阱
21:24 useDebounce
21:26~21:34 useDebounceFn 
21:35 用lodash已经实现的来
21;46 useLodashHOF 
21:54 useDebounce
22:00 内联样式传递对象
22:11 useVirtualList
22:17 useInfiniteScroll无线滚动
22:30 react的不可变数据 基于旧的数据创建新的数据
22:36 react深层次数据变化图 新的对象变化其余指向对应对象的属性
22:38 这就是结构共享 
22:43 git版本箭头指向前一个的原因 每一个版本与不可变数据的原理一样
22:46 IMMUTABLE曾经火过,已过时
22:58 很有用的url 
22:59 不可变数据在软件开发其它方面的影子
23:00 immer原生js实现不可变数据
23:05 immer改变对象 produce ??用法
23:11 immer todo
23:14 immer变更函数首参 小本本
23:19 传入对象不可能相等

## 11-2
20:04 函数组件里面的immer
20:06 函数组件todo,不可变数据写法
20:12 修改对象不会改变,创建才会改变
20:20 immer简化 var {produce}= immer
20:24 useImmer提取出来单独写一个变更函数
20:28 可以直接使用的useImmer react immer文档
20:30 这里的draft与immer一样 没变使用源对象,变了创建新对象
20:33 produce接多个参数,只有第一个不是原来的对象
20:37~20:48 produce不希望return
20:44 produce可以返回filter 但是只能在顶层(非嵌套) 
20:48 可以返回一个nothing
20:48 Map set 都会被转换成draft
20:49 Classes immerable
20:51 Cuurent 原始对象副本
20:52 Patches 补丁与反向补丁
20:54 inversechange
20:56 Auto freezing 冻结
20:57 createDraft/finishDraft produce套的太深可以用
21:09 一些其它的补充
21:10 深入JSX
21:14 UglifyJS minifier 代码难读化
21:16 _jsx现在会自动引入了
21:18 @jsx
21:20 jsx不能写中括号表达式
21:21 那jsx如何返回多个表达式
21:21 props默认是true
21:22 jsx会去掉行首和行尾的空格
21:23 组件也可以直接返回数组 要加key
21:26 &&
21:27 错误边界,防止一个小组件坏掉从而整个界面挂掉,只能在class里面用 vue-errorCapture
21:33 错误边界Test
21:45 fragment jsx只能渲染一个组件,不然就包一层
21:46 但是有些也不能包
21:48 React.fragment 也可以简写成<> <> 对就是空的 
21:51 React.fragment可以带key
21:52 协调 vue会对比真实与虚拟的差异,然后修改差异
21:53 react的各个部分 21:53
21:58~22:02 react是如何找差异的 react的协调 面试
22:02 key 关键 面试这个要说清楚
22:05 现在的框架是怎么在对比差异的
22:17 Render Props 函数作为渲染
22:22 Render Props大致相当于作用域插槽
22:23 横切关注点 => 逻辑复用
22:26 thing-i-dont-know-as-of-2018
22:38 严格模式
22:41 StrictMode
22:45 Portals  传送门
22:54 渲染传送门 不会在组件中出现 但是会渲染body子元素 一般是出现在body最后一个元素
22:57 ReactDOM.createPortal
22:58 Teleport 弹窗放在body很合适

## 11-3
20:02 高阶函数定义回顾 高阶组件 小本本
20:05 高阶组件一般以with开头命名 高阶组件一般格式
20:06 一般来说高阶组件函数都会使用传入的组件
20:12 react的多种逻辑利用机制 小本本
20:14~20:21 大体的逻辑复用例子
20:24 withSubscription
20:28 手写withSubscription
20:30 逻辑复用例子
20:35 一般来说写高阶组件都会把新组件接收到的props原样或大部分传给原组件 小本本
20:37 高阶组件有名字的时候需要改变在组件树中的名字 Comp.displayName Comp.name 
20:39 非受控组件 可能会问 编辑
20:41 defaltValue 只是提了一句
20"43 Profiler
20:45 Web Components 可以与 x-serach一起用 通常与命令式AIP(video)一起使用 声明式也可以 小本本
21:01 PropTypes 以被TS取代,已很少使用
21:06 静态属性与实例属性
21:08 FLOW静态类型检查器
21;10 codesandbox
21:12 stacklitz TS静态类型检查
21:24 TS 与 JSX
21:26 性能优化 Create React App
21:28 避免调停 vue会自动这样做
21:30 shouldComponentUpdate的作用图 性能优化图  面试
21:36 不可变数据的力量 新的创建 旧的不变 高效判断是否更新
21:38 signal
21:40 不同的性能优化面试 小本本
21:43 第三方库协同 时间线 
21:44 之前的一些组件库
22:05 第三方库协同
22:09~22:12 在react中使用高德地图大致代码 ??
22:17 aria可访问的互联网应用 适配身障人士
22:20 虚拟化列表/循环列表简单实现 常见面试题
22:29 具体做法
22:44 为什么只显示这些元素的方式 rowRender
22:48 scroll scrollend
22:57 healessUI ReactTable TanStack

## 11-4
20:03 useDebugValue
20:12 useDebugValue一般用在自定义hook
20:15 useDebugValue在调用的可能方案 new Error搜集调用了哪些
20:18 useDeferredValue
20:22 软件卡顿两种情况的简易解决 小本本
20:26 useDeferredValue讲解 用在渲染慢
20:32 会根据react的繁忙程度是否返回旧的值
20:33 useDeferredValue-useTransition实例代码
20:50 useDeferredValue运行逻辑图
21:06 useDeferredValue运行火焰图 间歇性渲染
21:22 useTransition 用在加载慢
21:23 [isPending,startTransition] =useTransition()
21:33 isPending
21:31 Fiber
21:39 useTransition router 不能异步
21:43 lazy 第一次显示后运行 不是立刻
21:44 react19 的hooks use 可以放到if里面 面试小概率会问  
21:47 use原理 它只接收的对象，所以不根据自己的顺序来区分，而是根据自己的参数来区分需要返回的值
21:48 use里面放promise的情况 一定要传不是现场创建的对象，而是之前已经创建好的对象 接promise的时候不要传新创建的，而要传在组件外面创建的
21:54 Suspense fallback处理use lazy
21:57 Suspense fallback嵌套加载时的顺序
22:10 18.3.1文档里面的一些其它内容
22:11 Suspense fallback可以传递组件
22:16 fiber架构 build-your-own-react 面试可能会问fiber架构
22:23 react是怎样渲染树的简易原理 没有使用递归 前序 可以间接性渲染
22:29 requestIdleCallback 浏览器空闲时调用回调
22:36 lazy 
22:37 startTransition 可以直接用 没有pending 
22:38 use 实例
22:47 createPortal传送门
22:50 children的函数 可以用于解决嵌套

## 11-5
20:02 Tabs 树形结构实现
20:08 children只有一个的时候直接是对象而不是数组 小本本
20:34 react流行的(全局状态管理库(类vues/pinia)) 小本本 
20:36 zustand
20:41 Jotai
20:42 react数据放在哪里
20:42 Jotai原子数据
20:46 Jotai异步读原子
20:59 Jotai核心API
21:04 recoil 似乎没人用
21:12 mobx 
21:17 makeObservable
21:21 Reactions
21:22 mobx React integration
21;32 订阅的是字段
21:33 vue里面上层组件props发生变化,但是下层props没有变化会免于更新 react传过来不同的对象都要更新 如何理解??
21:43 Local and rxternal state 组件的局部or外部状态 三种
21:46 框架组件应该是用来查的
21:49 更简便的更新方式useState(()=>new Timer()) 必须在oberver状态下
21:51 不需要一开始就使用局部状态 不要把UI状态放进来
21;56 有哪些情况下使用一般不合适的状态? 比较深的属性 计算属性 被多个组件共享的属性
22:13 尽量晚点从对象中读取数据
22:14 callback 回调组件可能需要包一层<Observer>
22:17 observer极简手写
22:19 建议使用尽量多的小组件(拆分组件)
22:20 尽量晚的解引用 dereference (尽量晚的从对象中读取数据)
22:21 valtio
22:25 监控变量 一般都是监控朴素对象
22:26 序列化与非序列化
22:32 preat/signal
22:34~22:39 preat初始化html
22:41 signal信号
22:50 深层次变化不可以
22:56 signal全局状态 本地状态

## 11-6
20:02 react vite todo项目
20:31 ESLint 代码检查工具,并不检查类型 不能使用var
20:47 ?. !.前面的肯定不为空
21:03 jotai-immer atomimmer atomWithImmer变更函数内给对象数据必须使用atomWithImmer
21:07 有深度的数据atomimmer 原始值   数据atom
21:12 vite简易架构运行图 浏览器与vite建立的是webSocket以消息为单位 有可能面试
21:17 e事件会有隐含的any 写成e:KeyboardEvent<HTMLInputElement> <>可以指定类型 
21:23 但是因为可能冒泡写成 e.currntTarget
21:32 Immer变更函数内,做对比时只能拿原始类型(string,boolean,number等)做对比,拿对象做对比始终不会相等 或者套上original 
21:41 const·setTodos·=useSetAtom(todosAtom) 只需要修改这个值的时候可以这样写
21:42 不能监控变量,可以直接返回
22:01 react router
22:02 一般来说表单是提交到服务器 但是router可以实现完全在前端提交表单
22:06 router不同版本的写法
22:08 有自动404界面 也可以写在errorElement
22:11 嵌套路由
22:16 一般前端的路由实现 
22:17 react router 前端的路由实现 数据会放在rootrouter里面
22:22 form
22:30 return redirect
22:31 editaction
22:37 edit
22:38 outlet 子路由
22:41 useParams地址栏接参数
22:42 navigate前进后退
22:44 memoryRouter Hash browser
22:47 嵌套的组件是怎样展示的

## 11-7
20:03 react router写
20:26 当子路由和路由同名时会显示哪一个 会显示顺序靠前的那一个
20:33 url末尾加/ 与不加的区别 不过一般都是一样的
20:37 服务器给界面发送的消息
20:40 NavLink会给className加一个函数,返回值作为类名
20:43 一般导航链接需要添加类名
20:46 编程式导航,运行这个函数就跳到哪里去
20:48 useNavigate -1 直接返回上一个界面
20:51 其实叫做页面栈 小程序的页面栈有多深6 小本本 
21:06 ssr
21:07 ssr是什么 npm run build
21:12 dist index请求图 react/vue网页请求到页面渲染图 有三个串行 重要
21:18 页面刷新出带数据的UI是计算了每一个步骤的时间
21:19 链接复用机制
21:20 传统网页请求到页面渲染图 ssr
21:22 网站越快越赚钱
21:24 浏览器自带有检测网页加载速度的工具
21:26 一般搜索都是流量最大的来源
21:27 SEO做的好,搜索就会靠前
21:28 Server side render服务端渲染
21:32 什么叫"渲染",render 界面出现 
21:33 更新dom也是渲染
21:35 拼接HTML字符串也叫render
21:36 什么是服务端渲染
21:37 框架也能做到服务端渲染
21:39 可以根据请求的地址提前在服务器渲染组件树
21:42 提前渲染图
21:46 服务端渲染页面里面已经存在的结构,框架渲染的时候就不用清除再重新渲染
21:48 hydration 水合/激活
21:50 会把框架的vnode事件绑定到html上 水合/激活
22:02 服务端渲染演示
22:11 react-dom会创建出字符串塞到服务端,实现服务端渲染
22:14 vue SSR ue也支持将组件在服务端直接渲染成HTML字符串，作为
服务端响应返回给浏览器，最后在浏览器端将静态的HTML“激活”（hydrate）为能够交
互的客户端应用。
22:16 为什么要用SSR 好处 SEO更好 更快加载 前后端同一语言 
22:18 搜索引擎如何决定网页排在第几位? 小本本
22:24 同步js索引
22:27 但是一般来说 面向用户的SSR都是配置好了的 to C 快速,引流
22:29 公司写一般都是面向后台写的 to B 无需SEO所以无需ssr 不追求很快的加载和运行速度
22:31 to C 和 to B是什么?区别 小本本
22:33 SSG 静态站点生成 预渲染 小本本
22:37 vue就是SSG
22:38 营销界面可以用SSG
22:44 node.js是在js非浏览器的运行环境 next.js 是运行在nodejs之上的基于react的网站开发框架.它集成了react的有功能并增加了自己的功能如ssr以及ssg  小本本
22:47 react server components 服务端组件
22:49 一些react全栈框架 next.js
22:51 一些vue全栈框架 nuxt
22:56 服务端组件  没有交互 实现业务逻辑并返回结果 小本本

## 11-8
20:03 Node.js是什么不是什么 小本本
20:12~20:24 一些其它类似node.js的环境 deno(可以运行TS),bun,mongodb(操作这个数据库的语言就是js),auto.js(用js脚本控制手机) 小本本
20:25 node.js一般用来做什么 小本本
20:28 Electron（将浏览器与Nodejs集成到一个环境中）
20:32 前端构建、前端工程化 小本本
20:53 什么是IO 数据不值直接存在内存里都算是IO
21:04 js是由运行环境提供IO,本身没有IO
21:14 thread_run 启动线程
21:17 join 等待
21:18 线程与浏览器woker的区别 小本本 线程可以使用同一份数据 woker是接收消息的复制数据
21:22 join图解 等待的过程
21:31 addEventListener 也是一种异步
21:33 share AB 似乎已经被禁用 安全原因
21:36 异步在系统中实现的简易过程 小本本 
21:41 进程 线程
21:43 标准输出流
21:52 bash shell壳 terminal终端 console控制台 的细微区别 小本本
22:14 argv
22:18 figlet-cli #!/usr/bin/env node 蟹棒shebang 是linux命令行的专用语法，用来标识当前脚本文件需要哪个可以执行程序来执行它 让node命令变得和命令行一样
22:18 factor2 如何将一个脚本加入bash
22:28 linux,max下文件当作程序执行怎么办 小本本
22:31 文件模式的组成 读,写,执行 小本本
22:37 硬链接,两个文件对应同一个inode 软连接类似快捷方式
22:41 硬链接创建ln [文件] [目标文件]如果复制粘贴,就失去了链接 只能在同一个磁盘同一个分区 小本本
22:46 软连接ln -s [文件] [目标文件] 类似快捷方式

## 11-9
20:03 factor2 非递归写法
20:06 无法访问的代码
20:14 globlThis通用全局变量
20:18 node现在已经能直接使用import
20:23 require / 是请求的这个盘的顶层
20:23 可以认为windows系统没有系统级顶层文件夹linux和mac系统的/目就是系统的顶层文件夹 小本本
20:27 require内置模块
20;31 import map 来实现import与require的结合
20:33 garble
20:34 module.export只导出一个模块 导出单个,多个可以放在一个对象中导出
20:38 require现在的写法,require('node:fs')内置模块,第三方模块直接写名字
20:41 node_modules 文件图 应该第三方模块都放到项目根目录的node_modules 没有的话会放到最顶层
20:43 绝大部分时候 npm install根据文件夹中是否有package.json文来决定这个文件夹是否是项目的根目录 小本本
20:46 package文件夹介绍 index默认是入口文件 
21:03 require(lodash/chunk)可以多来几个斜杠引入更多文件
21:04 node_modules not find 会一层一层向外找
21:08 nodejs现在也直接支持import加载esmodules
需要文件本身是模块文件，即扩展名为mjs
21:11 传统js 与模块文件msj的区分 小本本
21:13 在node的最新版本里，require可以引入esmodule
反过来好像也能引，即import也能引入common js模块
21:15 reguire, import的相对路径相对于那句路径所在文件,而其它的一些系统函数如fs.readFile(path)则是相对于工作目录 小本本 
21:20 require 不等于 require
21:31 figlet
21:33 node中几乎所有回调风格的函数，回调函数都是接收两个参数，第一参数是可能的错误，第二参数是结果
fs.readFile(aaa.txt',(etror, data) =>{}) 小本本
21:41 dependencies依赖 npm装依赖
22:02 yarn pnpm 快!
22:07~22:40 pnmp为什么快?缓存已下载的包 很有可能面试 小本本
22:10 用硬链接 软连接存储文件
22:27 就算有要找的文件,但是没有node_modules也不行
22:30~22:40 pnpm为什么节省空间 小本本
22:33 .pnmp-store
22:44 nodejs/js标准type的buffer 小本本 内存片段一个字节里面的字节
22:50 fs 都是第一个参数error第二个是回调 也有同步版本
22:55 同步需要捕获异常,否则直接抛到控制台
22:57 异步IO的好处,等待的时候做其它事情

## 11-10
20:03 listRecursive找出文件名及其文件夹下的嵌套文件名的同步写法
20:14 async版本
20:15 comjs顶层是不能加await的
20:17 回调版本
20:32 Promise
20:48 哪一个版本最快 包含解释
20:59 为何在硬盘上同时发起请求比一次一次发起好 
21:01 请求??
21:12 HTTP module模块
21:15 http-server.js 请求流程
21:39 服务器也能发请求
21:41 以AJEX为例解释xhr.send
21:43 node已经自带fetch
21:45 Axios
21:51 现在直接用fetch发送
22:02 http-static-server.js
22:28 --watch 监控文件变化直接重启 小本本
22:36 斜杠解决
22:39 fs.readdirSync('.'{withFileTypes:true})

## 11-11
20:05 http-static-server.js剩余的(文件夹路径末尾没有斜杠，需要跳转到带斜杠的地址/url中带有querystring，qs是不能作为文件名的，需要去掉/如果url对应文件夹，这应该列出文件夹内容/列出内容时，应该区分文件与文件夹，最好能显示文件大小)
20:18 一般多一个斜杠也没有问题// 电脑上的相对路径与网站的相对路径是不一样的
20:22 require('node:path') 内置模块能直接在nodejs控制台能直接用
20:30 PORT
20:33 ../
20:35 解决自动优先显示index.html
20:40 index.html是文件夹怎么办
20:41 只有一个res.write 可以直接在res.end()里面xie
20:45 列出文件夹的size
21:03 中文文件名需要解码
21:10 utf8够用
21:13 path.extname
21:18 mime等直接返回扩展名的npm库
21:24 mime-type 这个更好用
21:31 浏览器会自动转译 ../ 如果没有化简../ 可能会导致安全漏洞访问外面的文件
21:42 没有化简的根本解决方案,目标路径是不是在文件夹内 路径是不是在以这个开头的文件夹 (不过现在node似乎已经解决了这个安全问题)
22:07 nodejs调试 小本本 node --inspect-brk [path] 默认9929端口,可以修改
22:13 调试的话经常需要发送请求
22:17 可以直接在vscode里面调试
22:24 node API relative 
22:28 posix 处理不同系统路径不一样的情况
22:32  process
22:35 process.cwd
22:35 env
22:39 process.argv  process.execArgv
22:40 常用的process 小本本
22:42 querystring 解析查询模块 几乎不用 已被URL替代 path/fs/http主要这几个 小本本
22:46 error error.code错误代号
22:51 _dirname _filename 在模块内全局 小本本 
 
## 11-13 nodeAPI
20:02 setTimeout等都有 node里面返回的是是一个对象而不是一个整数 小本本
20:08 ref unref 整个node程序不要再对这个任务有所"引用”了，即这个任务的运行与否不影响程序的退出，即使这个任务还没有运行
20:08~20:14 程序在服务器与网页里面的运行模型
20:16 nodejs unref程序执行顺序 很少面试 小本本
20:21 Events EventEmitter 事件监听触发器 
20:25 emit(用了,但是没说)
20:28 class类里面也可以通过extend来使用
20:29 addListener
20:32 prependListener(提了一下) 还可以绑定多次事件 也可以解绑off
20:34 react里面没有事件机制 给组件传递函数在合适时机调用
20:35 EventEmitter常见面试题 实现一个EventEmitter类  小本本
20:39 EventTarget 浏览器nodejs都有
20:41 浏览器的EventTarget 返回true表示有代码处理这个事件
20:43 nodejs的EventTarget
20:44 浏览器不同类型的new Event
20:46 EventSource
20:47 nodejs buffer(放在全局,也可以require)
20:49 Buffer 重载
21:03 Buffer.allocUnsafe 内存分配,不一定会把之前的数据清除掉,不过一般没有这样做
21:08 buffer from
21:12 buffer里面字节的存储方法 字节序 LE BE
21:16 从左边存储的话加法会从右边叠加,从右边存储的话就不会
21:18 所以可以自信选择大端序或者小端序
21:20 大端序BE 小端序LE演示
21:24 atob btoa legacy已过时 已被Buffer.from('','')代替
21:30 localstorage指定存储地点
21:32 解构化克隆算法structuredClone 只有支持的数据才会被克隆 小本本
21:36 异步版本与同步版本风格read File例子
21:40 statSync里面一些状态的解析 小本本
21:48 net connect 如果就在本机上运行,可以直接把网址换成文件路径
21:52 isFIFO()是否是FIFO FIFO 是一种特殊的文件类型，允许数据以先进先出的方式进行读写
21:54 linux一切都是文件
22:07 文件太大readFileSync是读不出来的
fd:filedescriptor 文件描述符
22:09 用fileHandle 文件句柄 由文件描述符构造的class，可以直接调用class的方法案实现对文件的操作，而不必每次调用函数时传入文件描述符 小本本
22:14 fs.readSync(fd,buffer,offset,length[,position])一点一点的读buffer的数据
22:17 access权限检测
22:19 glob 一般配合ls查询用 小本本
22:24 **/* 深度不限 可以放到异步生成器
22:26 readdir fs.Dirent 可以结合异步生成器慢慢迭代大文件夹
22:30 FileHandle文件句柄 小本本
22:35 fs.FSWatcher 监控文件变化,但是不太好用
Chokidar更好用
22:38 arg parse yargs参数解析库 自动将命令行参数转换成对象
22:45 errors cause查看错误源
22:48 读文档的重要性

## 11-14
20:02 流Streams
20:04 什么是可写流 createWriteStream
20:09 write process.stdout.write是如何消耗数据的
20:12 流对象
20:13 write流的消耗是把数据放到硬盘里面
20:15 end关掉就write就写不进去了
20:18 read write也能通过buffer一点一点操作文件的片段
20:22 膜概念图 任何一个对象先想想里面在干嘛
20:28 可写流与可读流
20:32 一般来说服务器req是可读流,res是可写流;客户端req是可写流,res是可读流
20:34 node里面都有可能是异步的
20:36 可读流的一般写法,防止没有数据 on
20:39 浏览器也是有请求体的 放在流里面 试例
21:04 API for stream consumers API流消费者
21:08 Duplex 双攻流(在内部直接转换) Transform转换流(压缩流/解压流 加密解密流) 二者都可读可写
21:12 流 示例图 搬砖 
21:17 缓冲区的作用
21:20 back pressure 背压
21:24 objectmode dataView是TypeArray具体的数据类型
21:26 buffering缓冲区从数据源拿来会放到一个缓冲区(数组或者链表)然后再给你
21:29 缓冲区大小决定内存多少 highWaterMark
21:36 write返回false说明缓冲区满了,因为用户写得太快了占满了内存
21:38 读取大流的实例(读取了一个1G电影)
21:45 pause暂停从数据源读取数据 缓冲区满了先暂停 防止水位过高
21:47 drain resume 可写流完成时触发
21:50 pipe一个全部干了 限制缓冲
22:08 流在网络中整个传输的过程
22:14 逐级传导背压 因为每个阶段传导数据的速度不一样,所以用pipe来平衡,防止超过内存
22:18 pipe可以指定缓冲区大小,即使超过也不会丢掉数据(但是也可以设置丢掉)
22:23 后端中相对重要的概念 "流"
22:25 流对象的消费者 
22:27 流对象的实现者
22:28 流的使用者应该关心什么 小本本
22:29 流的实现者应该关心什么 小本本
22:32 drain 可写流里面的数据已经或者即将被用光 小本本
22:32 一些可写流重要的API close pipe 小本本
22:35 crock塞子 堵住流数据暂时不处理 uncrock
22:38 可读流 主动与被动读取 三种readableFlowing状态
(暂停,恢复,null)
22:40 readableFlowing null buffer会是[]空的
22:46 node里面几乎所有事件都是异步的 直接读取可能还没有加载到缓冲区中 读出来可能是空的
22:48 readable比起data可以精细控制读多少 data读多少有多少,一般64k 65536字节 
22:51 unshift 一般主动用 把读多了的数据放回去
22:55 对象模式的可读流就是数组 只不过数组分布在时间上
22:56 map
22:59 异步生成器也是随着时间变化慢慢出来若干数据
23:00 可读流也可以转换成异步生成器(二者可以相互转换) for await
23:01 RxJS 足够复杂才用

## 11-15
20:05~ 一些可读流数组上的node API
every map some toArray 返回的是promise,会在不同情况下返回 
20:09 迭代可读流 必须使用for await(var data of readable)处理异步可迭代对象
20:11 为什么可以for of一个可读流 因为可读流的形式与异步生成器很接近,所有都有相同的接口
20:14 readable.fromWeb迭代器创建可读流 生成器是迭代器: 生成器函数返回的生成器对象是一个迭代器，因此所有生成器都是迭代器。
20:17 readable.fromWeb异步生成器也可以创建可读流
20:20 rs.pipe(ws).pipe(ws2).pipe(ws3) 基本等价于下面,下面更好
20:21 stream.pipeline(rs,ws,ws2,ws3)
20:25 取消控制器AbortController 实例用法 虽然用起来很奇怪但是可以通用 小本本
20:29 node里面的AbortSignal
20:32 compose能组合流对象
20:37 compose还能搭配转换流,N多个流合成一个
20:38 Duplex and transform streams 双工流与转换流详解 转换流一定是双工流 双工流不一定是转换流
20:40 一些压缩与解压的流 zip Deflate
20:44 Gzip 实例
20:49 await fetch 返回的promise 可读流对象就是在读取body
20:53 tee 分流 三通
21:07 API for stream implementers 流的实现者
21:10 可读流读取数据 实例
21:11 生产数据read()
21:16 流里面不是对象模式都是存储的buffer
21:19 highWaterMark可以设置缓冲区最高字节读取数量
21:27 可写流读取数据 实例 write(chunk数据, encoding类型,callback数据处理完后的回调)promise API 有问题 不用看这段视频
21:31 appendFile(这是promise)有问题不用看这段视频
21:35 destroy
21:40 File system flags 可以添加状态来使文件夹修改或者添加等功能
21:41 虽然写入了数据,但是文件不一定有 promise API 有问题不用看这段视频
21:49 可写流读取数据 实例同步写法 
21:54 promise API 有问题 似乎是调用的时间顺序有问题
22:07 流不同的对象使用者和消费者是变化的
22:07 writev() 不需要按照顺序消费
22:11 writev() 图 多片段同时处理
22:13 双攻流\transform流实现简单实例
22"24 继承流的话想要成为可读流必须_read()
22:26 read()与_read()
22:30 一点点read()源码解析
22:33 异步生成器创建可读流
22:35 流还用在进程间的通信中 process.stdin(进程的标准输入流(可读流)) process.stdout(进程的标准输出流（可写流）) process.stderr (进程的标准错误流（可写流）)小本本 实际上它们是可以被视为 Socket 对象的一种实现
22:40 process.stdin process.stdout 实例
22:44 process.stderr 实例
22:48 可写流不能pipe 将可读流的数据通过 pipe 方法传输到可写流(双工流)
22:49 进程树 process monitor

## 11-16
20:02 class EventEmitter 面试常见??
20:15 EventTarget 与 EventEmit是有区别的 因为浏览器有DOM树的存在所以事件有可能连带触发 但是node没有
20:23 很少既写emit又写on
20:25 类型组合,很少用不如继承
20:35 交互控制台不可枚举的属性不可联想
20:38 socket其实继承自双攻流
20:50 进程的标准输入输出流
20:57 child_process 会返回一个ChildProcess对象
20:58 child_process.exec('ls -ha')
21:00 md5sum
21:04 unref解除绑定
21:06 进程运行图,每一个都有stdin stdout
21:09 两个程序的process对象都是不一样的
21:10 父子进程的可读可写流是不一样的
21:13 child_process.spawn('ls',['-l'])
数据有可能会消失,再绑一次
21:20 md5sum进程实例 ctrl+d结束
21:24 process与pipe一起使用
21:25 | 管道运算符
21:30 process使用pipe 添加append:true达到 > >> 的效果
21:35 0.0.0.0是任意网卡地址
21:38 子进程就是干这事的
21:39 detached解除绑定
21:40 process也有同步版本
21:41 node的一些用法 远程开发平台 wget curl
21:46 UI自动化
21:48 让异步process看起来像是同步 不常用
22:08 process fork 另外启动一个新的分支node
22:12 process send可以在不同work传递信息
22:13 IPC跨进程通信 subprocess子进程模块
22:17 SIGKILL 给进程发出exit信号,执行信号对应的操作
22:22 OS模块能读到一些操作系统信息
22:30 尽量用URL
22:31 querystring ?? 一些其它的API
22:33 qs模块 解析用
22:35 Punycode 域名解析
22:36 Util工具函数 现在似乎没啥用了
22:38 until.promisify 实例 promise转会回调 很有可能面试会手写这个玩意
22:42 Permission可以为node设定权限
22:44 assert断言 deepEqual
22:45 runner 测试运行器 与mocha效果一样
22:51 string docder没用了 都用UTF-8
22:51 single executable 单一运行环境exe,发给别人用不需要再安装依赖
22:53 Net Tcp Udp 模块 TLS安全连接(https依赖这个)
22:54 Domain 古早异步机制,早已不使用
22:55 DNS 解析域名

## 11-17
20:02 C++
20:04 Cluster 集群 让多个node看起来在同一个端口提供服务
20:07 main thread 一般跑不满核
20:09 可以开多个node跑 但是一个程序占用了端口另一个就不能用 Cluster解决它
20:11 Cluster原理 20:16 接收到链接,转发编号FD(由OS实现),这个编号就代表了链接的请求??
20:18 进程之间能通信但是不一定能共享数据
20:20 Cluster实例(并不能运行) 以及解析图
20:24 为什么次node节点都能监听80端口 实际上是主进程在看次node进程是不是需要,然后传递描述符
20:33 Cluster根本原理 一个链接一个数 然后传递
20:34 Crypto会调用TLS/SSL加密解密
20:35 diagnostics_channel 诊断 错误报告
20:37 Inspector 更加精细的调试 
20:39 Intl 国际化功能
20:40 node现在也有TS模块 直接运行TS
20:41 node版本,每半年发布一个大版本,奇数版本一般都不会是长期支持版本 LTS长期支持版本 面试
20:46 -g的安装与普通安装的区别 -g全局安装 小本本
20:48 npm run安装 run是怎样在文件里面运行的 小本本
20:50 npx 解决不同项目全局使用使用某工具不同版本的问题 
20:53 tsx安装后运行ts
20:55 settimeout在node里面返回一个timeout流对象 timeout和settimeoutID(在浏览器中的)在TS也是一个类型
21:07 Performance hooks Asynchooks在某些性能指标关键点上运行代码
21:08 异步上下文追踪
21:09 readline 在命令行里面请求用户输入 各种语言都有 小本本
21:14 process.stdin 将输入流打印到屏幕 不过不好用
21:15 在命令行输入的作用 以及大致运行图
21:20 realine用法 实例 await rl.question单次输入前面用错了
21:38 REPL 交互式命令行的对话
21:40 repl-play 实例 read eval
21:46 AI响应返回实例
21:50 流式返回,一个一个返回
21:51 key怎么找到的 
22:01 writer(output)
22:21 report 测试开发用
22:13 SQLite
22:14~27 Worker threads node里面的多线程 文档有现成的代码
22:15 主线程可以导出一些函数 parser
22:17 require一开始其实只是导出主线程后面就不是
2:18 __filename 双下划线就是代指所在文件的文件名
22:25 浏览器里面的worker()
22:27 crypto.randomUUID() 浏览器返回随机UUID 也称加密ID
22:30 V8引擎 虚拟机介绍
22:37 VM
22:42 但是最好不要在VM里面运行不受信任的代码
22:45 不能当作安全机制,除非限制 图
22:48 什么时候能用到VM
22:50 代码与副作用
22:54 WASI WebAssembly 杀手级应用 复杂程序运行在网页上也不会卡顿

## 11-18
20:02 简易文件服务器
20:06 http只是规定了格式 但是传递其它任方法或者头都可以,但是服务器要承认才有意义
20:26 同一个模块再次加载会直接从缓存里面跑一遍
20:33 error.code == "ENOENT"不存在这个文件
20:34 500 服务器错误
20:37 只要涉及到硬盘转动都是异步的
20:38 不能预料到的错误一般写500
20:51 不存在文件不算是错误返回204即可,成功但是无响应体
20:54 为什么删文件rmdir不需要error
20:56 idempotent幂等
21:01 为什么删除多次也要返回?
21:09 代码出错的时候如何找出问题的 确定问题是什么 测试 工作经验
21:18 结论mime-types是会区分正反斜杠的
21:22 curl
21:41 错误处理
21:42 异步错误不会向外层传 AI??
21:46 异步加 try catch已经没用了
21:51 集中式错误处理 同步处理
21:54 使用promise cath 来进行错误处理
22:00 promise抛出错误会直接失败 如果任何一个 Promise 被拒绝，后续的 then() 将不会被执行，直到遇到 catch()
22:07 bind(thisArg,arg1[, arg2[, ...]])
22:10 远程关机代码 

## 11-19
20:02 浏览器的事件循环
20:04 已经完成了的promise的回调是比setTimeout快的 这是由事件循环决定的 event loop
20:07~10 事件循环 面试必问 什么是异步IO 不会阻塞主线程
20:13 *poll*
20:18 C里面如何做到先有数据先等谁 select epoll(更高效)
20:24~30 Event LoopExplained图 ?? input 
20:26 setTimeout/Inter/Immediate... 没有进入循环,是在初始化阶段执行的 其中的回调是进入了事件循环的
20:29 每一个阶段都有FIFO队列
20:31 timers队列可以是有回调函数个数限制的
20:35 poll 回调太多了执行不了回到下一个pending里面去执行
20:36 node卡在poll的情况
20:40 setTimeout 修改含义 比预定延迟过后就不会执行了 图 AI??
20:42 timers 时间不一定准确,但是会尽量准确
20:43 为什么说timeers是由poll决定 
20:47 libuv 防止其它阶段没有函数,运行到一定时间必须离开
20:58 poll阶段 1.等待多久2.处理这个事件
21:02 close back控制不了什么时候调用
21:03 setTimeout-VS-setImmediate 实例 为什么有时候immediate先有时候settimeout先(先后顺序不确定的,i7似乎需要4ms才能看出差异)
21:08 process.nexTick() 每次调用栈清空就会执行这个回调 21:12 实例 运行图
21;21 证明每次调用栈清空才会执行
21:24 几秒中能运行几次的代码
21:25~21:27 setImmediate安排的回调运行图 
21:29 什么时候用process.nexTick() server.listen 
21:32 promise.resolve.then 21:33 resolve一按下去就是成功的了,而就在这一刻回调会被安排
21:36~38 process先Promise后 如果陷入了其中一个回调队列中间都会等待调用栈清空后执行
21:39 浏览器里面的事件循环 event loop 微任务与宏任务 小本本
21:43 MutationObserver 可以监控一个dom元素的变化，变了以后它会调用我们提供的函数，是通过微任务的方式调用的该函数 小本本
21:48 在元素变化然后在运行MutationObserver之前是没有进行渲染操作的 21:50火焰图
21:55 不同微任务有可能区分谁先谁后吗? AI??
21:56 为什么浏览器setTimeout与queueMicrotas在浏览器的运行时机不一样 因为谷歌浏览器的微任务是早于宏任务把浏览器的结果返回控制台 小本本
22:11 promise.resolve.then 在浏览器中 小本本 面试调用时机 
22:15 promise队列运行图 画一个队列图,promise只有在成功的时候才会加入队列 5与6的时机
22:22 还可以加上await版本
22:27 await也是在等待promise.then 可以搜时间循环面试题 7是在2完成后才加入队列的,3的加入要早于7
22:31 异步函数一定返回promise AI??
22:35 /author作业

## 11-20
20:02~20 一些题目时间循环题目 nextTick promise await setTimeout大集合 面试
20:25 express5.x 可以有很多插件 其它node框架几乎都是这个改过来的
20:30 express实例
20:31 node里面的use 
20:34 多个use会依次穿越处理 也叫中间键
20:38 如何知道函数参数数量 f.length
20:39 setTimeout是捕获不到throw的
20:40 中间件抛出怎么捕获 ,会抛出到处理错误的中间件里
20:42 next应该是最后一个逻辑
20:44 最后一个中间件调用end不掉next
20:59 express初始化项目
21:01 get也是中间件 get请求参数里的地址才会访问这个中间件
21:05 最后一个中间件应该处理404
21:07 express生成器 简介
21:08 express基本路由 app.METHOD(PATH,HANDLER)方法,路径,函数
21:10 use与其它方法的请求路径是由区别的 use是开头匹配就会进入中间件,其它是相同()除了/ 小本本
21:13 静态文件
21:21 如何给用户提供静态文件 用户需要哪个文件就返回哪一个 写出来的代码,现在一个中间件找,找不到就下一个再找
21:30 express.static
21:38 use一些的路径问题,中间件读到的是匹配路径后面的东西 小本本
21:43 也可以直接使用绝对路径
21:44 如何处理错误
21:45 node后端路由
21:47 head方法 相当于获取get请求的响应头小本本
21:49 不用写?=查询
21:50 正则表达式路由,几乎不会用
21:52 两种get多个中间件的不同写法
22:02 静态路由,数组中间件
22:04 一个中间件处理不了用另一个
22:06 静态文件中间件数组[]中间件的运用场景
22:08 响应方法res
22:11 触发浏览器下载对话框的响应头attachment;filename=["package.json"] 小本本 a标签的download的下载原理与这个是不一样的
22:14 route一个路径下多种请求方式
22:16 router效果解释图(子路由更贴切)
22:20 如何开发中间件
22:22 使用中间件 应用级(层)中间件
22:23 路由的路径参数 req.params.ID读取路径参数
22:26 都可以接多个中间件
22:27 '/',router 以router开头,怎么走看router里面怎么写的了
22:28 Router-level middleware 路由级别中间件
22:29 错误中间件一定是有四个参数 前面一个出错了会找到最近的一个
22:30 express中如何算出错了?  小本本
22:31 express.json
22:33 req上的body是空的,需要通过on 和async,await循环解析读出来 22:36 使用use(express.json)来解决 如果请求体是json格式（根据请求头的content-type）则把它读取并解析，放到req.body上
22:40 express.urlencoded() 如果请求体是url编码（普通的表单提交）（a=1&b=2这种形式）（根据请求头的content-type）则把它读取并解析
22:41 express.text() 如果请求体是纯文本（根据请求头的content-type）则把它读取并转换为宇符串，放到reg.body上
22"43 Overriding the Express APl
22:45 异步错误处理不掉直接next()集中处理
22:46 express5现在的中间件函数也可以是异步的了
22:46 promise失败也算是中间件出错了 ??
22:48 try..catch写在setTimeout里面是可以的 promise抛错
router导出
## 11-21
20:01 express-generator
20:09 app.set 可以与get形成映射
20:14 app.use(logger('[string]'))morgan包
20:17 render
20:21 node环境变量是如何读取的 process.env
20:26 set aaa=888 echo $888 linux添加环境变量 SET aaa=888 windows添加环境变量
20:30~44 SET DEBUG=myapp:* & npm start 是给debugger看的
20:31 npm run xxx 的运行逻辑 小本本
20:35 npm包debug
20:38 debug的log标签调用简化版 可以打印出不同的debug日志 会有颜色的区别 推荐阅读debug文档
20:48 说明APP就是一个函数
21:03 express API 
21:05 Methods
Application
21:10 app.rout
21:10 app.set(name,value) 有一些自带设置(大小写敏感,环境变量设置,etag响应头设置,)
21:12 set里面reolace的用法与JSON.stringify是差不多的,涉及到json格式之外的数据会用到比如函数
21:17 同时也能通过JSON.parse返回去
21:20 定制json序列化与返序列化有可能面试 小本本
21:22 query parser
21:22 strict routing 严格路由 /foo /foo/
21:23 views模板文件夹
21:24 x-powered-by 响应头添加
21:26 Request
21:28 req.baseUrl
21:28 req.body 用的比较多 根据中间件来确定body里面的值
21:30 req.fresh
21:30 req.host 请求方域名带端口,从请求头找出来的
21:21 req.ip 请求IP,从TCP找出来的(message.socket)
21:35 req.params
21:36 req.path
21:36 req.query 查询参数
21:38 req.subdomains 把子域名取出来
21:39 req.url最常用
21:39 Request Method
21:42 req.accepts() 解决了请求无法判断的问题 /author
21:44 req.accepts() tu req.acceptsCharsets() req.acceptsEncodings() req.acceptsLanguages()
21:45 req.is()请求头是什么
21:45 req.range() 实例 面试 小本本 断点续传是如何实现的
22:00 Response
22:01 res.attachment 下载
22:02 res.download可以指定文件名下载以及其它功能 断点续传
22:03 res.format 返回不同的函数
22:04 res.get(field) 匹配响应头
22:04 res.json 
22:05 rel.links翻页
22:07 res.location(path) 跳转 'back'会跳回上一个界面
22:11 res.set()
22;11 res.status(code). 可以链式调用
22:12 res.type 设置响应类型
22:12 res.vary() 添加vary头
22:13 常用的res
22:13 Router
22:15 thinkjs 目录结构与express是不一样的 快废了
22:16 hapi
22:24~4 jsonp 是什么 小本本
22:26 只有头里面有允许跨域的话才能跨域 cors跨域资源共享
22:27 以前没有cors的时候怎么做到的
22:29 通过script标签可以跨域加载其它域的资源 只能是get
22:30 为什么？xhr、fetch有跨域限制，为什么script加载没有限制? 小本本
script是我们信任服务器,除了流量外没有风险;xhr、fetch是服务器信任我们,拿到了完整资源随意处置,会有风险
22:43 还可以把数据抱在一个函数里面,但是需要声明函数 也可以放在一个变量上
22:47 jsonp的js扩展写法
22:52 jsonp与普通请求的区别 小本本
22:53 jsonp的函数实现 小本本 面试 cors AI??

## 11-22
