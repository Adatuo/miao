<script>
//几乎很多排序都要用到一个值进行中转交换
  function swap(array,i,j) {
    var t = array[i]
    array[i] = array[j]
    array[j] = t
  }

//randomArray自动生成随机数组
  function randomArray(n) {
    //放入随机数的空数组
    var result = []
    for (let i = 0; i < n; i++) {
      result.push(Math.random() * n | 0) //n | 0取整数  
    }
    return result
  }

//isSorted()，检测是否排过序了。前面一个“数” >=后面一个“数”
function isSorted(array) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] > array[i+1]) {
      return false
    } 
  }
  //没有这种情况返回true
  return true
}

//冒泡排序
  function bubbleSort(array) {
    //从后向前比,end不需要等于0，最后一个数不用比（因为最后一个数最大）
    for (let end = array.length - 1; end > 0; end--) {
      //swapped退出标记
      var swapped = false
      //交换
      for (let i = 0; i < end; i++) {
        if (array[i] > array[i + 1]) {
           swap(array,i,i+1)
           swapped = true
        } 
      }
      //当swapped没有变化，说明排序完毕退出
      if (swapped == false) {
        break
      }
    }
    return array
  }
  //冒泡排序中数组的变换流程
    /*### 初始数组
`[1, 8, 6, 9, 4, 3, 2]`

### 第一步：第一个for循环 end = 6
1. 比较 `1` 和 `8`，不交换。
2. 比较 `8` 和 `6`，交换：`[1, 6, 8, 9, 4, 3, 2]`
3. 比较 `8` 和 `9`，不交换。
4. 比较 `9` 和 `4`，交换：`[1, 6, 8, 4, 9, 3, 2]`
5. 比较 `9` 和 `3`，交换：`[1, 6, 8, 4, 3, 9, 2]`
6. 比较 `9` 和 `2`，交换：`[1, 6, 8, 4, 3, 2, 9]`

最大值 `9` 已经移动到最后。

### 第二步：第一个for循环 end = 5
1. 比较 `1` 和 `6`，不交换。
2. 比较 `6` 和 `8`，不交换。
3. 比较 `8` 和 `4`，交换：`[1, 6, 4, 8, 3, 2, 9]`
4. 比较 `8` 和 `3`，交换：`[1, 6, 4, 3, 8, 2, 9]`
5. 比较 `8` 和 `2`，交换：`[1, 6, 4, 3, 2, 8, 9]`

次大值 `8` 已经移动到倒数第二位。

### 第三步：第一个for循环 end = 4
1. 比较 `1` 和 `6`，不交换。
2. 比较 `6` 和 `4`，交换：`[1, 4, 6, 3, 2, 8, 9]`
3. 比较 `6` 和 `3`，交换：`[1, 4, 3, 6, 2, 8, 9]`
4. 比较 `6` 和 `2`，交换：`[1, 4, 3, 2, 6, 8, 9]`

第三大值 `6` 已经移动到倒数第三位。

### 第四步：第一个for循环 end = 3
1. 比较 `1` 和 `4`，不交换。
2. 比较 `4` 和 `3`，交换：`[1, 3, 4, 2, 6, 8, 9]`
3. 比较 `4` 和 `2`，交换：`[1, 3, 2, 4, 6, 8, 9]`

第四大值 `4` 已经移动到倒数第四位。

### 第五步：第一个for循环 end = 2
1. 比较 `1` 和 `3`，不交换。
2. 比较 `3` 和 `2`，交换：`[1, 2, 3, 4, 6, 8, 9]`

第五大值 `3` 已经移动到倒数第五位。

### 第六步：第一个for循环 end = 1
1. 比较 `1` 和 `2`，不交换。

此时数组已经排序完成。

### 最终排序结果
`[1, 2, 3, 4, 6, 8, 9]`

以上步骤逐步展示了冒泡排序的整个过程，每一轮循环会将当前未排序部分的最大值“冒泡”到数组的最后。*/
    /*冒泡排序是一种简单且直观的排序算法。它的基本思想是重复地遍历待排序的序列，一次比较两个元素，如果它们的顺序错误就交换它们的位置。这个过程会持续进行，直到整个序列没有需要交换的元素为止。冒泡排序的名称来源于其过程中的元素不断上浮（就像气泡一样）。

### 冒泡排序的基本思路

1. **初始化**：
   - 定义一个循环变量 `end`，它从数组的最后一个元素开始，逐渐向前移动，表示当前需要比较和交换的最后一个元素的位置。

2. **外层循环**：
   - 每次迭代时，将 `end` 向前移动一位，逐步缩小未排序的部分。

3. **内层循环**：
   - 从数组的第一个元素开始，逐个比较相邻的两个元素。如果前一个元素大于后一个元素，就交换它们的位置。
   - 内层循环的终点是 `end`，表示不需要再比较已经排序好的部分。

4. **交换**：
   - 通过不断比较和交换，较大的元素会逐渐向后移动，较小的元素会向前移动。

5. **优化**：
   - 添加一个标志变量 `swapped`，如果在某一轮比较中没有发生交换，则说明序列已经排序完毕，可以提前结束排序。

### 图示说明

假设有一个数组 `[1, 8, 6, 9, 4, 3, 2]`，下面是冒泡排序的执行过程：

1. **初始状态**： `[1, 8, 6, 9, 4, 3, 2]`
2. **第一轮**：
   - 比较 `1` 和 `8`，不用交换。
   - 比较 `8` 和 `6`，交换，结果：`[1, 6, 8, 9, 4, 3, 2]`
   - 比较 `8` 和 `9`，不用交换。
   - 比较 `9` 和 `4`，交换，结果：`[1, 6, 8, 4, 9, 3, 2]`
   - 比较 `9` 和 `3`，交换，结果：`[1, 6, 8, 4, 3, 9, 2]`
   - 比较 `9` 和 `2`，交换，结果：`[1, 6, 8, 4, 3, 2, 9]`
3. **第二轮**：
   - 比较 `1` 和 `6`，不用交换。
   - 比较 `6` 和 `8`，不用交换。
   - 比较 `8` 和 `4`，交换，结果：`[1, 6, 4, 8, 3, 2, 9]`
   - 比较 `8` 和 `3`，交换，结果：`[1, 6, 4, 3, 8, 2, 9]`
   - 比较 `8` 和 `2`，交换，结果：`[1, 6, 4, 3, 2, 8, 9]`
4. **第三轮**：
   - 比较 `1` 和 `6`，不用交换。
   - 比较 `6` 和 `4`，交换，结果：`[1, 4, 6, 3, 2, 8, 9]`
   - 比较 `6` 和 `3`，交换，结果：`[1, 4, 3, 6, 2, 8, 9]`
   - 比较 `6` 和 `2`，交换，结果：`[1, 4, 3, 2, 6, 8, 9]`
5. **第四轮**：
   - 比较 `1` 和 `4`，不用交换。
   - 比较 `4` 和 `3`，交换，结果：`[1, 3, 4, 2, 6, 8, 9]`
   - 比较 `4` 和 `2`，交换，结果：`[1, 3, 2, 4, 6, 8, 9]`
6. **第五轮**：
   - 比较 `1` 和 `3`，不用交换。
   - 比较 `3` 和 `2`，交换，结果：`[1, 2, 3, 4, 6, 8, 9]`
7. **第六轮**：
   - 比较 `1` 和 `2`，不用交换。

经过上述几轮比较和交换，最终数组变为 `[1, 2, 3, 4, 6, 8, 9]`，完成排序。*/
  
//选择排序
function selectSort(array) {
  //默认第一个最小，array.length - 1最后一个数不用比较
  for (let i = 0; i < array.length - 1; i++) {
    //minIdx最小值，用i的话会改变逻辑
    var minIdx = i
    //i后面跟前面的比较
    for (let j = i+1; j < array.length; j++) {
      if(array[j] < array[minIdx]){
        minIdx = j
      }
    }
    //更换位置
    swap(array,i,minIdx)
  }
  return array
}
  //插入排序原理+数组变换形式
  /*
  它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其主要特点是简单、适合小规模数据的排序。

  插入排序的步骤如下：
  1. 从第一个元素开始，该元素可以认为已经被排序。
  2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
  3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
  4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
  5. 将新元素插入到该位置后。
  6. 重复步骤2~5。

  ### 数组变化过程

假设排序数组 `[1,8,6,9,4,3,2]`，插入排序的过程如下：

1. 初始数组: `[1, 8, 6, 9, 4, 3, 2]`
2. 第一次循环 (`i = 1`): `current = 8`
   - `8` 与 `1` 比较，不需要交换。
   - 结果: `[1, 8, 6, 9, 4, 3, 2]`
3. 第二次循环 (`i = 2`): `current = 6`
   - `6` 与 `8` 比较，交换位置。
   - 结果: `[1, 6, 8, 9, 4, 3, 2]`
4. 第三次循环 (`i = 3`): `current = 9`
   - `9` 与 `8` 比较，不需要交换。
   - 结果: `[1, 6, 8, 9, 4, 3, 2]`
5. 第四次循环 (`i = 4`): `current = 4`
   - `4` 与 `9` 比较，交换位置。
   - `4` 与 `8` 比较，交换位置。
   - `4` 与 `6` 比较，交换位置。
   - 结果: `[1, 4, 6, 8, 9, 3, 2]`
6. 第五次循环 (`i = 5`): `current = 3`
   - `3` 与 `9` 比较，交换位置。
   - `3` 与 `8` 比较，交换位置。
   - `3` 与 `6` 比较，交换位置。
   - `3` 与 `4` 比较，交换位置。
   - 结果: `[1, 3, 4, 6, 8, 9, 2]`
7. 第六次循环 (`i = 6`): `current = 2`
   - `2` 与 `9` 比较，交换位置。
   - `2` 与 `8` 比较，交换位置。
   - `2` 与 `6` 比较，交换位置。
   - `2` 与 `4` 比较，交换位置。
   - `2` 与 `3` 比较，交换位置。
   - 结果: `[1, 2, 3, 4, 6, 8, 9]`
  */

//插入排序
function insertSort(array) {
  //
  for (let i = 1; i < array.length; i++) {
    for (let j = i - 1; j >= 0; j--) {
      //把后一个数字array[j + 1]，与前一个数字array[j]对比
      if (array[j] > array[j + 1]) {
        swap(array,j,j + 1)
      }else{
        break
      }  
    } 
  }
  return array
}
//gpt版本
function insertionSort(array) {
  for (let i = 1; i < array.length; i++) {
    let current = array[i];
    let j = i - 1;
    while (j >= 0 && array[j] > current) {
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = current;
  }
  return array;
}

//归并排序 递归的复杂度log有关
0(N * logN)
O(N)

//快速排序,2面试
function quickSort(array,p) {
  let z = []
  for (let i = 0; i < array.length; i++) {
   if (array[i]<p) {
    for (let j = 0; j <array[i].length; j++) {
      
      
    }
   }
   if (array[i]>p) {
    
  }  
  }
}

</script>