<script>
  //接口
  function plus(x,y) {
    return x + y
  }
  //接口
  function minus(x,y) {
    return x - y
  }
  //接口
    function length(x,y) {
    return Math.sqrt(x ** 2 - y ** 2)
  }
  //接口实例
  function Vector(x,y) {
    this.x = x
    this.y = y
  }
  
  Vector.prototype.plus = function(otherVector){//prototype是全局,Vector参数会被覆盖
    //返回新的Vector实例(return只能返回一个值)
    return new Vector(this.x + otherVector.x, this.y + otherVector.y)
  }

  Vector.prototype.minus = function(otherVector){
    //返回新的Vector实例(return只能返回一个值)
    return new Vector(this.x - otherVector.x , this.y - otherVector.y)
  }

  Vector.prototype.length = function(){
    //这里要返回数值
    return Math.sqrt(this.x ** 2 + this.y ** 2)
  }


  var v1 = new Vector(4,5);
  var v2 = new Vector(3,-4);
  //Vector.prototype.plus要先添加不然plus就没有被添加
  /*
  1. **`Vector` 构造函数**：
   ```javascript
   function Vector(x, y) {
     this.x = x;
     this.y = y;
   }
   ```
   这个构造函数用来创建一个新的 `Vector` 对象，并将 `x` 和 `y` 的值赋予该对象。
   使用 `new Vector(x, y)` 时，会调用这个构造函数，并返回一个包含属性 `x` 和 `y` 的新对象。

2. **`Vector.prototype.plus` 方法**：
   ```javascript
   Vector.prototype.plus = function(Vector) {
     return new Vector(this.x + Vector.x, this.y + Vector.y);
   }
   ```
   - `this.x` 和 `this.y`：在 `plus` 方法中，`this` 引用的是调用 `plus` 方法的 `Vector` 实例。因此，`this.x` 和 `this.y` 分别是该实例的 `x` 和 `y` 属性。
   - `Vector.x` 和 `Vector.y`：这里的 `Vector` 是 `plus` 方法的参数，它是另一个 `Vector` 对象。`Vector.x` 和 `Vector.y` 分别是传入的 `Vector` 对象的 `x` 和 `y` 属性。

3. **调用 `plus` 方法**：
   ```javascript
   var v1 = new Vector(4, 5);
   var v2 = new Vector(3, -4);
   var v3 = v1.plus(v2);
   ```
   - `new Vector(4, 5)` 创建一个新的 `Vector` 对象 `v1`，其 `x` 和 `y` 属性分别为 `4` 和 `5`。
   - `new Vector(3, -4)` 创建另一个 `Vector` 对象 `v2`，其 `x` 和 `y` 属性分别为 `3` 和 `-4`。
   - `v1.plus(v2)` 调用 `v1` 实例的 `plus` 方法，并将 `v2` 作为参数传递给该方法。在 `plus` 方法内部，`this` 引用 `v1`，`Vector` 引用 `v2`。返回的新 `Vector` 对象的 `x` 和 `y` 属性分别是 `v1` 和 `v2` 的 `x` 和 `y` 属性的和，即 `7` 和 `1`。

总结：
- **`new Vector(x, y)`** 创建一个新的 `Vector` 对象，其 `x` 和 `y` 属性分别由参数 `x` 和 `y` 初始化。
- **`this.x` 和 `this.y`** 在 `plus` 方法中引用调用该方法的 `Vector` 实例的属性。
- **`Vector.x` 和 `Vector.y`** 在 `plus` 方法中引用作为参数传递的另一个 `Vector` 对象的属性。
  */
  var v3 = v1.plus(v2) 
  /*
  otherVector.x = 3 ,otherVector.y = -4
  //Vector.prototype.plus下new调用的this
    this.x = 4 , this.y = 5
  */
  
  var v4 = v2.minus(v1)
  var l = v4.length()


  console.log(v3)
  console.log(v4)
  console.log(l)

  //复数接口实例
  function Complex(real,imag) {
    this.real = real
    this.imag = imag
  }

  //复数乘法接口
  function multiple(x,y) {
    return x * y
  }  

  //复数乘法接口
  function div(x,y) {
    return x / y
  }  

  Complex.prototype.plus = function(otherComplex){
    //返回新的Vector实例(return只能返回一个值)
    return new Complex(this.real + otherComplex.real , this.imag + otherComplex.imag)
  }

  Complex.prototype.minus = function(otherComplex){
    //返回新的Vector实例(return只能返回一个值)
    return new Complex(this.real - otherComplex.real , this.imag - otherComplex.imag)
  }

  Complex.prototype.multiple = function(otherComplex){
    //返回新的Vector实例(return只能返回一个值)
    return new Complex(
      (this.real * otherComplex.real - this.imag * otherComplex.imag)
    + (this.real * otherComplex.real + this.imag * otherComplex.imag)
    )
  }

  Complex.prototype.div = function(otherComplex){
    return new Complex(
      (this.real * otherComplex.real + this.imag * otherComplex.imag) / (otherComplex.real ** 2 + otherComplex.imag ** 2)
    , (this.imag * otherComplex.real - this.real * otherComplex.imag) / (otherComplex.real ** 2 + otherComplex.imag ** 2)
  )
  }

  Complex.prototype.toString = function(){
    return this.real + '+' + this.imag + 'i'
  }

  var c1 = new Complex(4,5) 
  var c2 = new Complex(1,-2)

  var c3 = c1.plus(c2)
  var c4 = c1.minus(c2)
  var c5 = c1.multiple(c2)
  var c6 = c1.div(c2)

  console.log(c3)
  console.log(c4)
  console.log(c5)
  console.log(c6)
  console.log(c6.toString())
</script>